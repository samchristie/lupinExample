{"version":3,"sources":["webpack:///webpack/bootstrap 2fc6c4915ef9ca3de5a1","webpack:///./src/index.js","webpack:///./~/riot/riot.js","webpack:///./~/lupin/src/lupin.js","webpack:///./~/most/most.js","webpack:///./~/most/lib/Stream.js","webpack:///./~/most/lib/base.js","webpack:///./~/most/lib/source/core.js","webpack:///./~/most/lib/source/ValueSource.js","webpack:///./~/most/lib/scheduler/PropagateTask.js","webpack:///./~/most/lib/fatalError.js","webpack:///./~/most/lib/disposable/Disposable.js","webpack:///./~/most/lib/disposable/EmptyDisposable.js","webpack:///./~/most/lib/source/from.js","webpack:///./~/most/lib/source/fromArray.js","webpack:///./~/most/lib/iterable.js","webpack:///./~/most/lib/source/fromIterable.js","webpack:///./~/most/lib/source/periodic.js","webpack:///./~/most/lib/source/MulticastSource.js","webpack:///./~/most/lib/Promise.js","webpack:///./~/most/~/when/lib/decorators/unhandledRejection.js","webpack:///./~/most/~/when/lib/env.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///vertx (ignored)","webpack:///(webpack)/buildin/amd-define.js","webpack:///./~/most/~/when/lib/format.js","webpack:///./~/most/~/when/lib/Promise.js","webpack:///./~/most/~/when/lib/makePromise.js","webpack:///./~/most/~/when/lib/Scheduler.js","webpack:///./~/most/lib/source/create.js","webpack:///./~/most/lib/sink/DeferredSink.js","webpack:///./~/most/lib/defer.js","webpack:///./~/most/lib/source/fromEvent.js","webpack:///./~/most/lib/combinator/lift.js","webpack:///./~/most/lib/combinator/combine.js","webpack:///./~/most/lib/combinator/transform.js","webpack:///./~/most/lib/fusion/Map.js","webpack:///./~/most/lib/sink/Pipe.js","webpack:///./~/most/lib/fusion/Filter.js","webpack:///./~/most/lib/fusion/FilterMap.js","webpack:///./~/most/lib/sink/IndexSink.js","webpack:///./~/most/lib/disposable/CompoundDisposable.js","webpack:///./~/most/lib/invoke.js","webpack:///./~/most/lib/combinator/observe.js","webpack:///./~/most/lib/runSource.js","webpack:///./~/most/lib/sink/Observer.js","webpack:///./~/most/lib/disposable/SettableDisposable.js","webpack:///./~/most/lib/scheduler/defaultScheduler.js","webpack:///./~/most/lib/scheduler/Scheduler.js","webpack:///./~/most/lib/combinator/loop.js","webpack:///./~/most/lib/combinator/accumulate.js","webpack:///./~/most/lib/source/unfold.js","webpack:///./~/most/lib/source/iterate.js","webpack:///./~/most/lib/source/generate.js","webpack:///./~/most/lib/combinator/build.js","webpack:///./~/most/lib/combinator/concatMap.js","webpack:///./~/most/lib/combinator/mergeConcurrently.js","webpack:///./~/most/lib/disposable/AwaitingDisposable.js","webpack:///./~/most/lib/LinkedList.js","webpack:///./~/most/lib/combinator/applicative.js","webpack:///./~/most/lib/combinator/transduce.js","webpack:///./~/most/lib/combinator/flatMap.js","webpack:///./~/most/lib/combinator/flatMapEnd.js","webpack:///./~/most/lib/combinator/merge.js","webpack:///./~/most/lib/combinator/sample.js","webpack:///./~/most/lib/combinator/zip.js","webpack:///./~/most/lib/Queue.js","webpack:///./~/most/lib/combinator/switch.js","webpack:///./~/most/lib/combinator/timeslice.js","webpack:///./~/most/lib/combinator/slice.js","webpack:///./~/most/lib/combinator/filter.js","webpack:///./~/most/lib/combinator/delay.js","webpack:///./~/most/lib/combinator/timestamp.js","webpack:///./~/most/lib/combinator/limit.js","webpack:///./~/most/lib/combinator/promises.js","webpack:///./~/most/lib/combinator/errors.js","webpack:///./~/most/lib/combinator/multicast.js","webpack:///./~/lupin/src/bus.js","webpack:///./~/lupin/src/split.js","webpack:///./~/immutable/dist/immutable.js","webpack:///./src/todo/module.js","webpack:///./src/todo/model.js","webpack:///./src/todo/processor.js","webpack:///./src/todo/signals.js","webpack:///./src/todo/tags.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACnCA,aAAY,CAAC;;;;;;;;KAGN,IAAI,uCAAM,CAAM;;;;KAGhB,KAAK,uCAAM,CAAO;;;;;;KAKlB,SAAS,uCAAM,EAAW;;;;AAIjC,KAAI,IAAI,GAAG,KAAK,CAAE,SAAS,CAAC,GAAG,EAAE,CAAC,CAAC;;;AAGnC,KAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;;;AAGhD,KAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;;;;;;;KAOlC,IAAI,+CAAM,EAAe;;AACrC,KAAI,CAAC,IAAI,CAAE,IAAI,CAAC,C;;;;;;AChChB;;AAEA,EAAC;AACD;AACA,aAAY,gCAAgC,EAAE;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAA+C;AAC/C;AACA;;AAEA;AACA;AACA,aAAY;AACZ;;AAEA;;AAEA;AACA;AACA;;AAEA,qBAAoB;AACpB,oCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,WAAW;AACzB,gBAAe,SAAS;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA,IAAG;;AAEH;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,WAAW;AAC1B,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,oBAAoB;AACjD;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,IAAG;;AAEH;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,WAAW;AAC1B,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,SAAS;AACxB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;;AAEA;;AAEA;;AAEA,0BAAyB,aAAa;AACtC;AACA;;AAEA;AACA;AACA,UAAS,YAAY;AACrB,6BAA4B;AAC5B;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA,IAAG;;AAEH;;AAEA;AACA;AACA,EAAC,iBAAiB;;AAElB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,kBAAkB;AAC7B,YAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA,8DAA6D,WAAW;AACxE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAgB,EAAE;;AAElB;AACA;AACA;AACA,SAAQ,gBAAgB;AACxB;;AAEA;AACA;AACA;AACA;;AAEA,oCAAmC;;AAEnC,2BAA0B;;AAE1B;AACA;AACA,2BAA0B,yBAAyB;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA,8DAA6D,SAAS,iBAAiB,GAAG,GAAG;AAC7F,+BAA8B,EAAE;AAChC,kCAAiC;AACjC,2CAA0C;AAC1C,iCAAgC,gDAAgD;AAChF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO,0DAA0D,IAAI;AACrE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oCAAmC;;AAEnC,uCAAsC;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAqB,kBAAkB;;AAEvC;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA,uBAAsB;;AAEtB;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA,+BAA8B;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;;AAEtB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mEAAkE;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB;;AAEvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,mBAAkB,oBAAoB,SAAS,UAAU;AACzD;;AAEA;;AAEA;AACA,uBAAsB,aAAa;AACnC;AACA;AACA;;AAEA,2BAA0B;AAC1B;AACA,eAAc,qBAAqB;AACnC;;AAEA;AACA;;AAEA;AACA,+BAA8B;;AAE9B;;AAEA,EAAC;;;AAGD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,EAAC;;AAED;AACA;AACA,cAAa,SAAS;AACtB,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,QAAQ;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,MAAM;AACnB,cAAa,SAAS;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAkC,sBAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,IAAG;;AAEH;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA8C,uBAAuB;AACrE;;AAEA;AACA;AACA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,gBAAe,uBAAuB;;AAEtC;AACA;AACA;AACA;;AAEA,iCAAgC,iCAAiC;AACjE,kBAAiB,oBAAoB;;AAErC,MAAK;;AAEL;AACA;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAgB,iDAAiD,EAAE;;AAEnE;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mDAAkD,sBAAsB;AACxE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;;AAGH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;;AAEH;;AAEA;AACA,sCAAqC,yCAAyC;;AAE9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,WAAW;AACtB,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,MAAM;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA,2BAA0B,uCAAuC;AACjE,8BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,MAAK;AACL;;AAEA,mBAAkB,OAAO;AACzB,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB,cAAa,QAAQ;AACrB;AACA;AACA,gDAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,qBAAqB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,IAAI;AACjB,aAAY,SAAS;AACrB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA,eAAc;AACd,iBAAgB,uBAAuB;AACvC,yBAAwB;AACxB;AACA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,IAAI;AACjB,cAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,QAAQ;AACrB;AACA,sBAAqB;;AAErB;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,WAAW;AACxB;AACA;AACA;AACA,+CAA8C,GAAG,GAAG;;AAEpD;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,qBAAqB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA,qBAAoB,sCAAsC;AAC1D,qBAAoB;;AAEpB,EAAC;;AAED;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAuC,yBAAyB;;AAEhE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,SAAS;AACxB,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,WAAW;AACxB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,WAAW;AACxB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAuB,8BAA8B;AACrD;AACA;;AAEA,EAAC;;;;;;;;;;;;;;;;;KC1sEM,MAAM,uCAAM,CAAM;;KAClB,GAAG,uCAAM,EAAO;;KAChB,KAAK,uCAAM,EAAS;;;;;;;;;;;;;;AAc3B,UAAS,OAAO,CAAC,GAAG,EAAE,IAAI,EAAE;AAC1B,UAAO,IAAI,GAAG,CAAC,GAAG,IAAI,EAAE,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,GAAG;EAC7C;;AAED,UAAS,aAAa,CAAC,UAAU,EAAE;AACjC,UAAO,gBAAkB,MAAM,EAAE;;;SAAhB,KAAK;;AACpB,SAAI,SAAS,GAAG,UAAU,CAAC,MAAM,CAC/B,iBAAmB,GAAG,EAAK;;;WAAzB,KAAK;WAAE,OAAO;;kBACD,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC;;;;WAA1B,CAAC;AAAF,WAAI,CAAC,YAAsB;AAC3B,cAAG,GAAG,CAAE,CAAC,EAAE,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,CAAE;AACpC,cAAO,GAAG;MACX,EAAE,CAAC,KAAK,CAAC,CAAC;AACb,YAAO,SAAS;IACjB;EACF;;AAED,UAAS,aAAa,CAAC,MAAM,EAAE,SAAS,EAAE;AACxC,UAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAC1B,GAAG,CAAC,WAAC;YAAI,CAAC,CAAC,MAAM,CAAC;IAAA,CAAC,CACnB,KAAK,CAAC,WAAC;YAAI,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;IAAA,CAAC,CAC1B,GAAG,CAAC,WAAC;YAAI,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;IAAA,CAAC,CAC5B,KAAK,EAAE;EACX;;AAED,UAAS,MAAM,CAAC,KAAK,EAAE,MAAM,EAAE;AAC7B,OAAI,MAAM,CAAC,IAAI,IAAI,YAAY,EAAE;AAC/B,YAAO,CAAC,MAAM,CAAC,KAAK,CAAC;IACtB;AACD,UAAO,CAAC,KAAK,CAAC;EACf;;AAED,UAAS,KAAK,CAAC,YAAY,EAAE;AACvB,iBAAU,GAAG,CAAC,MAAM,CAAC;AACrB,gBAAS,GAAG,EAAE;AACd,cAAO,GAAG,GAAG,EAAE;AACf,aAAM,GAAG,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,EACzB,CAAC,YAAY,CAAC,CAAC;gBAClB,KAAK,CAAC,MAAM,CAAC;;;;OAA/B,KAAK;;AAAN,OAAQ,OAAO,cAAiB;;AAEhC,YAAK,GAAG;AACN,eAAU,EAAV,UAAU,EAAE,OAAO,EAAP,OAAO,EAAE,KAAK,EAAL,KAAK,EAAE,SAAS,EAAT,SAAS;AACrC,YAAO,EAAE,OAAO,CACb,MAAM,CAAC,WAAC;cAAI,CAAC,KAAK,SAAS;MAAA,CAAC,CAC5B,KAAK,CAAC,WAAC;cAAI,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;MAAA,CAAC,CAC1B,SAAS,EAAE;;AAEd,aAAQ,oBAAC,GAAG,EAAE;AACZ,WAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC;MAC1B;;AAED,SAAI,gBAAC,KAAK,EAAE;AACV,WAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAC,IAAI,EAAE,YAAY,EAAE,KAAK,EAAL,KAAK,EAAC,CAAC;MAC/C;IACF;AACD,uBAAgB,GAAG,KAAK,CAAC,OAAO,CAC/B,KAAK,CAAC,WAAC;YAAI,aAAa,CAAC,CAAC,EAAE,SAAS,CAAC;IAAA,CAAC;;AAE5C,QAAK,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC;AACpC,UAAO,KAAK;EACb;;sBAEc,KAAK;SACZ,KAAK,GAAL,KAAK;SAAE,MAAM,GAAN,MAAM,C;;;;;;AC9ErB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,YAAW,oDAAoD;AAC/D;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,yBAAyB;AACpC;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA,YAAW,2BAA2B,iBAAiB;AACvD,YAAW,EAAE;AACb,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,0BAA0B;AACrC,YAAW,EAAE;AACb,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,0BAA0B;AACrC,YAAW,EAAE;AACb,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,EAAE;AACb,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,cAAc;AACzB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,EAAE;AACb,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,gBAAgB;AAC3B;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAY,SAAS;AACrB,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,qBAAqB;AAChC,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAW,qBAAqB;AAChC;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAW,sBAAsB;AACjC,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,sBAAsB;AACjC,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAW,oCAAoC;AAC/C,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,sBAAsB;AACjC,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,2BAA2B;AACtC,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,sBAAsB;AACjC,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,sBAAsB;AACjC,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mCAAkC;;AAElC;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,eAAe;AAC1B;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAW,gBAAgB;AAC3B,cAAa,QAAQ,qBAAqB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,yBAAyB;AACpC,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;;;;;;AC1pBA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;ACRA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B,KAAK;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,UAAS,SAAS;AAClB;AACA;AACA,cAAa,KAAK;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,KAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvJA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAW,EAAE;AACb,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACjEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACxBA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACvDA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAE;AACF,E;;;;;;ACVA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClBA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,0C;;;;;;ACVA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,E;;;;;;ACpBA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA6B,oBAAoB;AACjD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;AC7CA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;AC9BA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;;;;;;;AC1CA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW;AACX,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACrCA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,YAAY;AAC1B;AACA;AACA,G;;;;;;AC3FA;AACA;AACA;;AAEA;AACA;;;;;;;ACLA;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,uBAAuB;AAC3C,qBAAoB,qBAAqB;;AAEzC;AACA,qBAAoB,sBAAsB;AAC1C,qBAAoB,qBAAqB;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAC;AACD,EAAC,wBAA+G;;;;;;;+CCrFhH;AACA;AACA;;AAEA;AACA,oBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAiC,0BAA0B;AAC3D,gCAA+B,wBAAwB;AACvD,2BAA0B,iCAAiC;;AAE3D;AACA,iBAAgB;AAChB,wBAAuB,4BAA4B;;AAEnD,GAAE,gDAAgD;AAClD;;AAEA,GAAE,gCAAgC;AAClC;AACA;AACA,gCAA+B,8BAA8B;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,sBAAsB;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,EAAC,wBAA+G;;;;;;;;ACxEhH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;AC1FtC,gB;;;;;;ACAA,8BAA6B,mDAAmD;;;;;;;ACAhF;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,EAAE;AACd,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,EAAE;AACd,aAAY,EAAE;AACd,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA,EAAC;AACD,EAAC,wBAAwG;;;;;;;ACvDzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF,EAAC;AACD,EAAC,yBAAiH;;;;;;;mCChBlH;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc,EAAE;AAChB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,EAAE;AACf,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA,iCAAgC;AAChC;;AAEA;AACA,2BAA0B,kBAAkB;AAC5C;AACA,gBAAe;AACf;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,UAAU;AACvB,cAAa,UAAU;AACvB,cAAa,UAAU;AACvB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa,UAAU;AACvB,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,MAAM;AACnB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,2CAA2C;AAChE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,mBAAmB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,EAAE;AACf,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,wBAAwB;AACrC,gBAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,EAAE;AACf,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,eAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB,cAAc;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,gBAAgB;AAC7B,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAAyB,cAAc;AACvC,0BAAyB,aAAa;AACtC,0BAAyB,aAAa;AACtC;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAc,YAAY,YAAY;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,cAAa,EAAE;AACf,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,EAAE;AACf,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA,QAAO;;AAEP;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,EAAC;AACD,EAAC,wBAAwG;;;;;;;;AC95BzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ,oBAAoB;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA,cAAa,yBAAyB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,EAAC;AACD,EAAC,wBAAwG;;;;;;;AC/EzG;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA,E;;;;;;ACvFA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAA+B;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8BAA6B,KAAK;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACtFA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA,E;;;;;;AClBA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,yBAAyB;AACpC,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA,GAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,KAAK;AACpB;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA,E;;;;;;ACxGA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,4EAA2E;AAC3E,oCAAmC;AACnC,OAAM;;AAEN;AACA,E;;;;;;AC3BA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,sBAAsB;AACjC,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,sBAAsB;AACjC,YAAW,SAAS;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAwB,KAAK;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9FA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAW,cAAc;AACzB,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,EAAE;AACb,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA,YAAW,gBAAgB;AAC3B;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;;;;;;;AC7CA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,cAAc;AACzB,aAAY,cAAc;AAC1B,cAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACtDA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC1BA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,sBAAsB;AACjC,aAAY,cAAc;AAC1B,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AChDA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC/BA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,8BAA8B;AACjD;;AAEA;;;;;;;AC5CA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;ACxBA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;AClBA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,gBAAgB;AAC3B,YAAW,UAAU;AACrB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;;;;;;AC7BA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAE;AACF;;;;;;;ACvBA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;;;;;;;AC7CA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC5CA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzDA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;AACF;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT;;;;;;;AChNA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA,YAAW,2BAA2B,iBAAiB;AACvD,YAAW,EAAE;AACb,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AClDA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,0BAA0B;AACrC,YAAW,EAAE;AACb,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,0BAA0B;AACrC,YAAW,EAAE;AACb,YAAW,OAAO;AAClB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;AC9FA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,kBAAkB,8BAA8B,UAAU,8BAA8B,EAAE;AACrG;AACA;AACA,YAAW,EAAE;AACb,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;ACzEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,2BAA2B;AACtC,YAAW,EAAE;AACb,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;;;;;;;ACpEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAE;AACF;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,G;;;;;;ACtEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAW,EAAE;AACb,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,G;;;;;;ACpFA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,qBAAqB;AAChC,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;;;;;;ACtBA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC/GA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClBA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,sDAAsD;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,sDAAsD;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,G;;;;;;AC7EA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACxBA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAY,SAAS;AACrB,aAAY,OAAO;AACnB;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1HA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,qBAAqB;AAChC,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,kBAAkB;AAC7B,cAAa,UAAU;AACvB;AACA;AACA;AACA;;;;;;;AC7BA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,G;;;;;;ACzDA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,MAAM;AACjB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,sBAAsB;AACjC,YAAW,OAAO;AAClB;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAmB,KAAK;AACxB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC9GA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAwB,KAAK;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpIA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA;;;;;;;;AC/DA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;AC1BA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;ACzHA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACjKA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAW,sBAAsB;AACjC,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,2BAA2B;AACtC,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACzEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACpDA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,oBAAoB;AACzC;;;;;;;AC9BA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/GA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;;;;;;;AC1HA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,yBAAyB;AACpC,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,EAAE;AACb,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0DAAyD,kBAAkB,EAAE;;AAE7E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,G;;;;;;AClFA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;;;;;;;;;;SCZgB,GAAG,GAAH,GAAG;;;;;KATZ,IAAI,uCAAM,CAAM;;AAEvB,KAAI,YAAY,CAAC;AACjB,KAAI,OAAO,YAAY,KAAK,WAAW,IAAI,YAAY,KAAK,IAAI,EAAE;AAChE,eAAY,GAAG,UAAS,CAAC,EAAE;AACzB,YAAO,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACzB,CAAC;EACH;;AAEM,UAAS,GAAG,CAAC,OAAO,EAAE;AAC3B,OAAI,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC;AAC3B,OAAI,GAAG,IAAI,GAAG,MAAM,GAAG,IAAI,CAAC;AAC5B,KAAE,GAAG,IAAI,CAAC,MAAM,CAAC,UAAS,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE;AACzC,SAAI,GAAG,GAAG,CAAC;AACX,SAAI,GAAG,GAAG,CAAC;AACX,YAAO,MAAM,GAAG,KAAK,CAAC;IACvB,CAAC,CAAC;AACH,KAAE,CAAC,IAAI,GAAG,UAAS,CAAC,EAAE;AACpB,YAAO,YAAY,CAAC,YAAW;AAC7B,cAAO,OAAO,IAAI,KAAK,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;MACtD,CAAC,CAAC;IACJ,CAAC;AACF,KAAE,CAAC,GAAG,GAAG,YAAW;AAClB,YAAO,YAAY,CAAC,YAAW;AAC7B,cAAO,OAAO,IAAI,KAAK,UAAU,GAAG,IAAI,EAAE,GAAG,KAAK,CAAC,CAAC;MACrD,CAAC,CAAC;IACJ,CAAC;AACF,KAAE,CAAC,KAAK,GAAG,UAAS,CAAC,EAAE;AACrB,YAAO,YAAY,CAAC,YAAW;AAC7B,cAAO,OAAO,MAAM,KAAK,UAAU,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;MAC1D,CAAC,CAAC;IACJ,CAAC;AACF,KAAE,CAAC,IAAI,GAAG,UAAS,EAAE,EAAE;AACrB,SAAI,EAAE,CAAC;AACP,OAAE,GAAG,GAAG,EAAE,CAAC;AACX,OAAE,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;AACpB,OAAE,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;AACpB,YAAO,EAAE,CAAC,GAAG,CAAC;IACf,CAAC;AACF,OAAI,OAAO,IAAI,IAAI,EAAE;AACnB,OAAE,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAClB;AACD,KAAE,CAAC,OAAO,CAAC,YAAU,EAAE,CAAC;AACxB,UAAO,EAAE,CAAC;EACX;;AAAA,EAAC;sBACa,GAAG,C;;;;;;;;;;;kBC1CM,KAAK;;KAHtB,MAAM,uCAAM,CAAM;;AAGV,UAAS,KAAK,CAAC,MAAM,EAAY;OAAV,MAAM,gCAAC,CAAC;;AAC5C,OAAI,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE;AAC1B,OAAI,OAAO,GAAG,EAAE;AAChB,OAAI,OAAO,MAAM,IAAI,QAAQ,EAAE;AAC7B,UAAK,IAAI,CAAC,GAAC,CAAC,EAAE,CAAC,GAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;AAC3B,aAAI,CAAC,GAAG,CAAC;AACT,gBAAO,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,WAAC;kBAAI,CAAC,CAAC,MAAM,GAAG,CAAC;UAAA,CAAC,CAAC,GAAG,CAAC,WAAC;kBAAI,CAAC,CAAC,CAAC,CAAC;UAAA,CAAC,CAAC;;MACzD;IACF,MAAM;AACL,YAAO,GAAG,EAAE;AACZ,WAAM,CAAC,OAAO,CAAC,WAAC,EAAI;AAClB,cAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,WAAC;gBAAI,CAAC,CAAC,CAAC,CAAC;QAAA,CAAC;MAC9B,CAAC;IACH;AACD,UAAO,OAAO;;;;;;;ACjBhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,oBAAoB,cAAc;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAuB;AACvB,oBAAmB;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,4DAA2D,wBAAwB;AACnF;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,aAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAmC,KAAK;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;;;;AAKA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,4CAA2C;;AAE3C,8CAA6C;;AAE7C,0CAAyC;;;AAGzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;AACA,oFAAmF,yCAAyC;AAC5H;AACA;AACA,kFAAiF,yCAAyC;AAC1H;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB;AAChB,iBAAgB;AAChB;AACA;AACA;AACA,8EAA6E;AAC7E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA8B,SAAS;AACvC;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qDAAoD;AACpD;AACA;AACA,kDAAiD;AACjD;AACA;AACA;;AAEA,gEAA+D;AAC/D;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;;AAEA,kEAAiE;AACjE;AACA;AACA;AACA,4BAA2B,wBAAwB;AACnD;AACA,2BAA0B,4CAA4C;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oEAAmE;AACnE;AACA,iDAAgD,mCAAmC;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gEAA+D;AAC/D,iDAAgD,wBAAwB;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,2DAA0D;AAC1D,4CAA2C;AAC3C;AACA;AACA,wCAAuC;AACvC,6CAA4C;AAC5C;AACA,8DAA6D;AAC7D,kDAAiD,kCAAkC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,gEAA+D;AAC/D;AACA,6BAA4B,8DAA8D;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C;AACA;AACA;AACA,6CAA4C;AAC5C;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP,mDAAkD;AAClD;AACA,0DAAyD;AACzD,kDAAiD,wBAAwB;AACzE;AACA;AACA,iCAAgC;AAChC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA,MAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA,MAAK;AACL;AACA,uCAAsC,oCAAoC;AAC1E;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;;AAEA;AACA;;;AAGA;AACA;AACA,6DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,gEAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA,8DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,gEAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK,uBAAuB,oBAAoB;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;;;AAGA;AACA;AACA;AACA,mEAAkE;AAClE;AACA;AACA,UAAS;AACT,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA,mCAAkC,6CAA6C;AAC/E;AACA,wBAAuB,uBAAuB,EAAE;AAChD,wBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,mCAAmC;AACjE,kCAAiC,kDAAkD;AACnF;AACA,MAAK;AACL,+CAA8C,4CAA4C;AAC1F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,8DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,gBAAgB;AAC9D,6CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,eAAe;AACpE;AACA,QAAO;AACP;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,qBAAqB;AAC7D,UAAS;AACT;;AAEA;AACA,oCAAmC,KAAK;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,2DAA0D,SAAS;AACnE;;AAEA;AACA;AACA;;AAEA;AACA,kDAAiD,eAAe;AAChE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,0DAAyD;AACzD;AACA;;AAEA,yDAAwD;AACxD;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8DAA6D;AAC7D;AACA;;AAEA,6DAA4D;AAC5D;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+DAA8D;AAC9D;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA,oDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,uCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,wCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;AACT;AACA;AACA;AACA,uBAAsB,mBAAmB;AACzC;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,aAAa;AACjC;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,sBAAsB;AAC5D,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAwB,oBAAoB;AAC5C;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAwB,oBAAoB;AAC5C;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kDAAiD;AACjD;AACA;;AAEA;AACA;AACA;;AAEA,sDAAqD;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,qBAAqB;AAC7D,UAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA,2CAA0C,KAAK;AAC/C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6DAA4D;AAC5D;AACA,2BAA0B,+CAA+C;AACzE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA,sDAAqD,wCAAwC;AAC7F,6DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,kBAAkB;AACvD,UAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAmC,KAAK;AACxC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gDAA+C;AAC/C,0CAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,mBAAmB;AAC3C,4DAA2D,sBAAsB;AACjF;AACA,QAAO;AACP;;AAEA,oDAAmD;AACnD;AACA;AACA;AACA,0CAAyC,yBAAyB;AAClE;AACA;AACA;AACA,6CAA4C,4BAA4B;AACxE;AACA;AACA,UAAS;AACT,QAAO;AACP;;AAEA,mDAAkD;AAClD;AACA;AACA;AACA,0CAAyC,yBAAyB;AAClE;AACA;AACA;AACA,2CAA0C,4BAA4B;AACtE;AACA;AACA,UAAS;AACT,QAAO;AACP;;AAEA;AACA;AACA;;AAEA,0DAAyD;AACzD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+DAA8D;AAC9D,mDAAkD,wBAAwB;AAC1E;;AAEA;AACA,6CAA4C,SAAS;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,kBAAkB;AACvD,UAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA0C,KAAK;AAC/C;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oDAAmD,KAAK;AACxD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4DAA2D;AAC3D,sEAAqE,qBAAqB;AAC1F;;AAEA,yDAAwD;AACxD,sEAAqE,qBAAqB;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA2D;AAC3D;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,qCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,kDAAiD,cAAc,EAAE;AACjE;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,2BAA0B;AAC1B;AACA,MAAK;;AAEL;AACA;AACA,2BAA0B;AAC1B;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,uCAAsC,eAAe,EAAE;AACvD;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;;AAEA,yBAAwB;AACxB;AACA,MAAK;;AAEL;AACA,0CAAyC,8BAA8B;AACvE,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA,MAAK;;AAEL;AACA,kFAAiF,YAAY;AAC7F,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD;AAClD;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA,2CAA0C,0BAA0B;AACpE,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,2CAA0C,4BAA4B;AACtE,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,wBAAwB;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;;;AAIH;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA,6CAA4C,8BAA8B;AAC1E,MAAK;;AAEL;AACA,iDAAgD,8BAA8B;AAC9E,MAAK;;AAEL,4CAA2C;AAC3C;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA,MAAK;;AAEL,yCAAwC;AACxC;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;AACA;AACA,8DAA6D;;;;AAI7D;;AAEA;;AAEA;AACA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,sCAAqC,qBAAqB;AAC1D,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;;;;AAIA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA;;AAEA,IAAG;;AAEH;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,8CAA8C,EAAE;AAC3E,4BAA2B,yCAAyC,EAAE;AACtE;AACA,yBAAwB,0BAA0B,EAAE;AACpD,yBAAwB,qBAAqB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAwD;AACxD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,EAAC,G;;;;;;;;;;SCn1Je,IAAI,GAAJ,IAAI;;;;;;;;KARb,SAAS,uCAAM,EAAW;;KAC1B,IAAI,uCAAM,CAAM;;KAGhB,UAAU,uCAAM,EAAS;;KACzB,SAAS,uCAAM,EAAgB;;qBAC/B,EAAW;;AAEX,UAAS,IAAI,CAAE,IAAI,EAAE;;;AAG1B,OAAI,CAAC,QAAQ,CAAE,SAAS,CAAC,CAAC;;;AAG1B,OAAI,CAAC,KAAK,CAAC,UAAU,EAAE,EAAC,IAAI,EAAJ,IAAI,EAAC,CAAC,CAAC;;;;;;;;;;;;SCNjB,IAAI,GAAJ,IAAI;;;;;;;;;;;KANb,SAAS,uCAAM,EAAW;;;AAG1B,KAAM,UAAU,GAAG,OAAO,CAAC,QAArB,UAAU,GAAV,UAAU;;AAGhB,UAAS,IAAI,CAAC,KAAK,EAAE,WAAW,EAAE;;;AAGvC,WAAS,IAAI,GAAG;AACjB,YAAS,EAAE,GAAG;;AAEV,WAAO,CAAE,CAAC,CAAC,GAAC,IAAI,CAAC,MAAM,EAAE,IAAE,KAAO,GAAE,CAAC,EAAE,QAAQ,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IACpE;;;AAGD,UAAO,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,IAAI,GACtC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,EAAC,CAAC,CAAC,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,WAAW,EAAE,CAAC;GACvE;;AAED,SAAO,SAAS,CAAC,MAAM,CAAE;AACvB,KAAE,EAAE,IAAI,EAAE;AACb,QAAK,EAAL,KAAK;AACL,cAAW,EAAX,WAAW;AACX,OAAI,EAAE,KAAK;GACT,CAAC;;;;;;;;;;;AC3BJ,aAAY,CAAC;;;;;;;;kBAMW,SAAS;;KAL1B,SAAS,uCAAM,EAAW;;KACrB,MAAM,+CAAM,EAAW;;;;kCACF,EAAS;;KAAjC,IAAI,UAAJ,IAAI;KAAE,UAAU,UAAV,UAAU;;AAGV,UAAS,SAAS,CAAE,KAAK,EAAE,MAAM,EAAE;;;AAGhD,WAAQ,MAAM,CAAC,IAAI;AACjB,UAAK,MAAM,CAAC,QAAQ;AAClB,YAAK,GAAG,KAAK,CAAC,KAAK;;AAEjB,QAAE,UAAU,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAE;;AAErC,aAAM,CAAC,IAAI,CACZ,CAAC;AACF,aAAM;;AAER,UAAK,MAAM,CAAC,WAAW;;AAErB,YAAK,GAAG,KAAK,CAAC,QAAQ,CAAE,CAAE,UAAU,EAAE,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,EAAE,cAAI;gBAAI,CAAC,IAAI;QAAA,CAAC,CAAC;AAC1E,aAAM;;AAER,UAAK,MAAM,CAAC,WAAW;;AAErB,YAAK,GAAG,KAAK,CAAC,MAAM,CAAE,UAAU,EAC9B,eAAK;gBAAI,KAAK,CAAC,SAAS,CAAE,cAAI;kBAAI,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;UAAA,CAAC;QAAA,CAAC,CAAC;;AAEvD,aAAM;;AAER,UAAK,MAAM,CAAC,UAAU;;;;;AAKpB,YAAK,GAAG,KAAK,CAAC,GAAG,CAAE,UAAU,EAAE,SAAS,CAAC,GAAG,EAAE,CAAC,CAAC;;AAElD,aAAM;AAAA,IACP;AACD,UAAO,CAAC,KAAK,CAAC,CAAC;;;;;;;;;;;;SC5BD,OAAO,GAAP,OAAO;SACP,UAAU,GAAV,UAAU;SACV,UAAU,GAAV,UAAU;SACV,SAAS,GAAT,SAAS;;;;;;;;;;;;;;AATlB,KAAM,QAAQ,GAAG,UAAU,CAAC,QAAtB,QAAQ,GAAR,QAAQ;;AACd,KAAM,WAAW,GAAG,aAAa,SAA3B,WAAW,GAAX,WAAW;;AACjB,KAAM,WAAW,GAAG,YAAY,SAA1B,WAAW,GAAX,WAAW;;AACjB,KAAM,UAAU,GAAG,WAAW,SAAxB,UAAU,GAAV,UAAU;;AAGhB,UAAS,OAAO,CAAE,IAAI,EAAE;AAAE,SAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAJ,IAAI,EAAE,CAAC;EAAE;;AAC5D,UAAS,UAAU,CAAE,GAAG,EAAE;AAAE,SAAO,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,EAAH,GAAG,EAAE,CAAC;EAAE;;AAChE,UAAS,UAAU,GAAI;AAAE,SAAO,EAAE,IAAI,EAAE,WAAW,EAAE,CAAC;EAAE;;AACxD,UAAS,SAAS,GAAI;AAAE,SAAO,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC;;;;;;;;;;;;;KCnBpD,IAAI,uCAAM,CAAM;;KAChB,KAAK,uCAAM,CAAO;;KACb,MAAM,+CAAM,EAAW;;KAC5B,SAAS,uCAAM,EAAW;;kCACA,EAAS;;KAAjC,IAAI,UAAJ,IAAI;KAAE,UAAU,UAAV,UAAU;;AAEzB,KAAI,CAAC,GAAG,CAAC,UAAU,wTAWjB,UAAS,IAAI,EAAE;;;;AAEb,OAAI,CAAC,EAAE,CAAC,OAAO,EAAE;YAAM,MAAK,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,MAAM,CAAC,SAAS,EAAE,CAAC;IAAA,CAAC,CAAC;EAC1E,CAEF,CAAC;;AAGF,KAAI,CAAC,GAAG,CAAC,WAAW,oRAOlB,UAAS,IAAI,EAAE;;;AACb,OAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;;AAE1B,OAAI,CAAC,GAAG,GAAG,UAAC,CAAC,EAAK;;AAEhB,SAAI,MAAK,SAAS,CAAC,KAAK,EAAE;AACxB,WAAI,CAAC,OAAO,CAAC,IAAI;AACf,aAAM,CAAC,OAAO;;AAEZ,WAAI,CAAE,MAAK,SAAS,CAAC,KAAK,EAAE,MAAK,eAAe,CAAC,KAAK,CAAC,CACxD,CACF,CAAC;;AAEF,aAAK,SAAS,CAAC,KAAK,GAAG,EAAE,CAAC;AAC1B,aAAK,eAAe,CAAC,KAAK,GAAG,EAAE,CAAC;MACjC;IACF,CAAC;;AAEF,OAAI,CAAC,KAAK,GAAG,UAAC,CAAC,EAAK;;;AAGlB,SAAI,CAAC,OAAO,CAAC,IAAI,CAAE,MAAM,CAAC,UAAU,EAAE,CAAE,CAAC;IAC1C,CAAC;EACH,CAEF,CAAC;;AAGF,KAAI,CAAC,GAAG,CAAC,WAAW,2JAQlB,UAAS,IAAI,EAAE;;;;AAEb,OAAI,EAAE,SAAS,IAAI,IAAI,CAAC,EAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;;;AAG/C,OAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAE,UAAC,KAAK,EAAK;;;AAGvC,SAAI,GAAG,GAAG,KAAK,CAAC,GAAG,CAAE,UAAU,CAAC,CAAC;;AAEjC,SAAI,GAAG,KAAK,SAAS;AACjB,WAAK,OAAO,KAAK,GAAG,EAAE;;;AAExB,aAAK,OAAO,GAAG,GAAG,CAAC;;AAEnB,aAAK,MAAM,EAAE,CAAC;MACf;IACF,CAAC;EACH,CAEF,CAAC;;AAGF,KAAI,CAAC,GAAG,CAAC,WAAW,gIAMlB,UAAS,IAAI,EAAE;;;;AAEb,OAAI,CAAC,MAAM,GAAG,YAAM;;AAElB,WAAK,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI;;AAEzB,WAAM,CAAC,UAAU,CAAE,MAAK,IAAI,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,CAC5C,CAAC;IACH;EACF,CAEF,C","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 2fc6c4915ef9ca3de5a1\n **/","/*\n Simple Todo app leveraging riot, lupin and Immutable\n */\n'use strict';\n\n// riot provides the light weight means to implement MVVM and custom tags.\nimport Riot from 'riot';\n\n//lupin provides a simple event/state distribution subsystem\nimport Lupin from 'lupin';\n\n//using immutable so that we can easily compare\n//versions of the objects so we can optimize UI updates \n//and can support undo operations.\nimport Immutable from 'immutable';  \n\n//Create the event dispatcher - state manager instance\n// this should be part of lupin\nlet core = Lupin( Immutable.Map());\n\n//generate easy console handles for debug of each event\ncore.signals.observe(console.log.bind(console));\n\n//generate easy console handles for debug of the state on every state change\ncore.state.observe(console.log.bind(console));\n\n// load the modules of the application\n//This todo application is a bit more complex than necessary so you \n//can scale the example into a more substantial application\n//This example is defined in modules - but there is only one module\n\nimport * as todo from './todo/module';\ntodo.init( core);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/* Riot v2.3.1, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function(window, undefined) {\n  'use strict';\nvar riot = { version: 'v2.3.1', settings: {} },\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n\n  // counter to give a unique id to all the Tag instances\n  __uid = 0,\n  // tags instances cache\n  __virtualDom = [],\n  // tags implementation cache\n  __tagImpl = {},\n\n  /**\n   * Const\n   */\n  // riot specific prefixes\n  RIOT_PREFIX = 'riot-',\n  RIOT_TAG = RIOT_PREFIX + 'tag',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n  // special native tags that cannot be treated like the others\n  SPECIAL_TAGS_REGEX = /^(?:opt(ion|group)|tbody|col|t[rhd])$/,\n  RESERVED_WORDS_BLACKLIST = ['_item', '_id', '_parent', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (window && window.document || {}).documentMode | 0\n/* istanbul ignore next */\nriot.observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables and methods\n   */\n\n  var callbacks = {},\n    onEachEvent = function(e, fn) { e.replace(/\\S+/g, fn) },\n    defineProperty = function (key, value) {\n      Object.defineProperty(el, key, {\n        value: value,\n        enumerable: false,\n        writable: false,\n        configurable: false\n      })\n    }\n\n  /**\n   * Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.\n   * @param  { String } events - events ids\n   * @param  { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('on', function(events, fn) {\n    if (typeof fn != 'function')  return el\n\n    onEachEvent(events, function(name, pos) {\n      (callbacks[name] = callbacks[name] || []).push(fn)\n      fn.typed = pos > 0\n    })\n\n    return el\n  })\n\n  /**\n   * Removes the given space separated list of `events` listeners\n   * @param   { String } events - events ids\n   * @param   { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('off', function(events, fn) {\n    if (events == '*') callbacks = {}\n    else {\n      onEachEvent(events, function(name) {\n        if (fn) {\n          var arr = callbacks[name]\n          for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n            if (cb == fn) arr.splice(i--, 1)\n          }\n        } else delete callbacks[name]\n      })\n    }\n    return el\n  })\n\n  /**\n   * Listen to the given space separated list of `events` and execute the `callback` at most once\n   * @param   { String } events - events ids\n   * @param   { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('one', function(events, fn) {\n    function on() {\n      el.off(events, on)\n      fn.apply(el, arguments)\n    }\n    return el.on(events, on)\n  })\n\n  /**\n   * Execute all callback functions that listen to the given space separated list of `events`\n   * @param   { String } events - events ids\n   * @returns { Object } el\n   */\n\n  defineProperty('trigger', function(events) {\n\n    // getting the arguments\n    // skipping the first one\n    var arglen = arguments.length - 1,\n      args = new Array(arglen)\n    for (var i = 0; i < arglen; i++) {\n      args[i] = arguments[i + 1]\n    }\n\n    onEachEvent(events, function(name) {\n\n      var fns = (callbacks[name] || []).slice(0)\n\n      for (var i = 0, fn; fn = fns[i]; ++i) {\n        if (fn.busy) return\n        fn.busy = 1\n\n        try {\n          fn.apply(el, fn.typed ? [name].concat(args) : args)\n        } catch (e) { /* error */}\n        if (fns[i] !== fn) { i-- }\n        fn.busy = 0\n      }\n\n      if (callbacks.all && name != 'all')\n        el.trigger.apply(el, ['all', name].concat(args))\n\n    })\n\n    return el\n  })\n\n  return el\n\n}\n/* istanbul ignore next */\n;(function(riot) { if (!window) return;\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\n\nvar RE_ORIGIN = /^.+?\\/+[^\\/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  REPLACE = 'replace',\n  POPSTATE = 'popstate',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = window,\n  doc = document,\n  loc = win.history.location || win.location, // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  started = false,\n  central = riot.observable(),\n  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n    args = path.match(re)\n\n  if (args) return args.slice(1)\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = []\n  riot.observable(this) // make it observable\n  central.on('stop', this.s.bind(this))\n  central.on('emit', this.e.bind(this))\n}\n\nfunction normalize(path) {\n  return path[REPLACE](/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] == '#'\n    ? (href || loc.href).split(base)[1] || ''\n    : getPathFromRoot(href)[REPLACE](base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel == 0\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\n  emitStackLevel++\n  emitStack.push(function() {\n    var path = getPathFromBase()\n    if (force || path != current) {\n      central[TRIGGER]('emit', path)\n      current = path\n    }\n  })\n  if (isRoot) {\n    while (emitStack.length) {\n      emitStack[0]()\n      emitStack.shift()\n    }\n    emitStackLevel = 0\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which != 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) return\n\n  var el = e.target\n  while (el && el.nodeName != 'A') el = el.parentNode\n  if (\n    !el || el.nodeName != 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target != '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n  ) return\n\n  if (el.href != loc.href) {\n    if (el.href.split('#')[0] == loc.href.split('#')[0]) return // internal jump\n    go(getPathFromBase(el.href), el.title || doc.title)\n  }\n  e.preventDefault()\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n */\nfunction go(path, title) {\n  title = title || doc.title\n  // browsers ignores the second parameter `title`\n  history.pushState(null, title, base + normalize(path))\n  // so we need to set it manually\n  doc.title = title\n  emit()\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n */\nprot.m = function(first, second) {\n  if (isString(first) && (!second || isString(second))) go(first, second)\n  else if (second) this.r(first, second)\n  else this.r('@', first)\n}\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*')\n  this.$ = []\n}\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n    if (args) {\n      this[TRIGGER].apply(null, [filter].concat(args))\n      return true // exit from loop\n    }\n  }, this)\n}\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter != '@') {\n    filter = '/' + normalize(filter)\n    this.$.push(filter)\n  }\n  this.on(filter, action)\n}\n\nvar mainRouter = new Router()\nvar route = mainRouter.m.bind(mainRouter)\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router()\n  // stop only this sub-router\n  newSubRouter.m.stop = newSubRouter.s.bind(newSubRouter)\n  // return sub-router's main method\n  return newSubRouter.m.bind(newSubRouter)\n}\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#'\n  current = getPathFromBase() // recalculate current path\n}\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true)\n}\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER\n    secondParser = DEFAULT_SECOND_PARSER\n  }\n  if (fn) parser = fn\n  if (fn2) secondParser = fn2\n}\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {}\n  loc.href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n  return q\n}\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    win[REMOVE_EVENT_LISTENER](POPSTATE, emit)\n    doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n    central[TRIGGER]('stop')\n    started = false\n  }\n}\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    win[ADD_EVENT_LISTENER](POPSTATE, emit)\n    doc[ADD_EVENT_LISTENER](clickEvent, click)\n    started = true\n  }\n  if (autoExec) emit(true)\n}\n\n/** Prepare the router **/\nroute.base()\nroute.parser()\n\nriot.route = route\n})(riot)\n/* istanbul ignore next */\n\n/**\n * The riot template engine\n * @version 2.3.0\n */\n\n/**\n * @module brackets\n *\n * `brackets         `  Returns a string or regex based on its parameter:\n *                      With a number returns the current left (0) or right (1) brackets.\n *                      With a regex, returns the original regex if the current brackets\n *                      are the default, or a new one with the default brackets replaced\n *                      by the current custom brackets.\n *                      WARNING: recreated regexes discards the `/i` and `/m` flags.\n * `brackets.settings`  This object mirrors the `riot.settings` object, you can assign this\n *                      if riot is not in context.\n * `brackets.set     `  The recommended option to change the current tiot brackets, check\n *                      its parameter and reconfigures the internal state immediately.\n */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB  = 'g',\n\n    MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n    STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBSRC = STRINGS.source + '|' +\n      /(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/])/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    DEFAULT = '{ }',\n\n    FINDBRACES = {\n      '(': _regExp('([()])|'   + S_QBSRC, REGLOB),\n      '[': _regExp('([[\\\\]])|' + S_QBSRC, REGLOB),\n      '{': _regExp('([{}])|'   + S_QBSRC, REGLOB)\n    }\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _pairs = []\n\n  function _regExp(source, flags) { return new RegExp(source, flags) }\n\n  function _loopback(re) { return re }\n\n  function _rewrite(re) {\n    return new RegExp(\n      re.source.replace(/{/g, _pairs[2]).replace(/}/g, _pairs[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _reset(pair) {\n    pair = pair || DEFAULT\n\n    if (pair !== _pairs[8]) {\n      var bp = pair.split(' ')\n\n      if (pair === DEFAULT) {\n        _pairs = bp.concat(bp)\n        _regex = _loopback\n      }\n      else {\n        if (bp.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) {\n          throw new Error('Unsupported brackets \"' + pair + '\"')\n        }\n        _pairs = bp.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n        _regex = _rewrite\n      }\n      _pairs[4] = _regex(_pairs[1].length > 1 ? /(?:^|[^\\\\]){[\\S\\s]*?}/ : /(?:^|[^\\\\]){[^}]*}/)\n      _pairs[5] = _regex(/\\\\({|})/g)\n      _pairs[6] = _regex(/(\\\\?)({)/g)\n      _pairs[7] = _regExp('(\\\\\\\\?)(?:([[({])|(' + _pairs[3] + '))|' + S_QBSRC, REGLOB)\n      _pairs[9] = _regExp(/^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S+)\\s*}/)\n      _pairs[8] = pair\n    }\n    _brackets.settings.brackets = cachedBrackets = pair\n  }\n\n  function _set(pair) {\n    if (cachedBrackets !== pair) {\n      _reset(pair)\n    }\n  }\n\n  function _brackets(reOrIdx) {\n    _set(_brackets.settings.brackets)\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _pairs[reOrIdx]\n  }\n\n  _brackets.split = function split(str, tmpl) {\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _brackets(6)\n\n    isexpr = start = re.lastIndex = 0\n\n    while (match = re.exec(str)) {\n\n      pos = match.index\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(match[2], re.lastIndex)\n          continue\n        }\n\n        if (!match[3])\n          continue\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos))\n        start = re.lastIndex\n        re = _pairs[6 + (isexpr ^= 1)]\n        re.lastIndex = start\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start))\n    }\n\n    return parts\n\n    function unescapeStr(str) {\n      if (tmpl || isexpr)\n        parts.push(str && str.replace(_pairs[5], '$1'))\n      else\n        parts.push(str)\n    }\n\n    function skipBraces(ch, pos) {\n      var\n        match,\n        recch = FINDBRACES[ch],\n        level = 1\n      recch.lastIndex = pos\n\n      while (match = recch.exec(str)) {\n        if (match[1] &&\n          !(match[1] === ch ? ++level : --level)) break\n      }\n      return match ? recch.lastIndex : str.length\n    }\n  }\n\n  _brackets.hasExpr = function hasExpr(str) {\n    return _brackets(4).test(str)\n  }\n\n  _brackets.loopKeys = function loopKeys(expr) {\n    var m = expr.match(_brackets(9))\n    return m ?\n      { key: m[1], pos: m[2], val: _pairs[0] + m[3] + _pairs[1] } : { val: expr.trim() }\n  }\n\n  _brackets.array = function array(pair) {\n    if (pair != null) _reset(pair)\n    return _pairs\n  }\n\n  /* istanbul ignore next: in the node version riot is not in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n  _brackets.set = _set\n\n  _brackets.R_STRINGS = STRINGS\n  _brackets.R_MLCOMMS = MLCOMMS\n  _brackets.S_QBLOCKS = S_QBSRC\n\n  _reset(_brackets.settings.brackets)\n\n  return _brackets\n\n})()\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var\n    FALSE  = !1,\n    _cache = {}\n\n  function _tmpl(str, data) {\n    if (!str) return str\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr\n\n  _tmpl.loopKeys = brackets.loopKeys\n\n  _tmpl.errorHandler = FALSE\n\n  function _logErr(err, ctx) {\n\n    if (_tmpl.errorHandler) {\n\n      err.riotData = {\n        tagName: ctx && ctx.root && ctx.root.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      }\n      _tmpl.errorHandler(err)\n    }\n  }\n\n  function _create(str) {\n\n    var expr = _getTmpl(str)\n    if (expr.slice(0, 11) !== \"try{return \") expr = 'return ' + expr\n\n    return new Function('E', expr + ';')  // eslint-disable-line indent\n  }\n\n  var\n    RE_QBLOCK = new RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_QBMARK = /\\x01(\\d+)~/g\n\n  function _getTmpl(str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str, 1)\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = []\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i]\n\n        if (expr && (expr = i & 1 ?\n\n              _parseExpr(expr, 1, qstr) :\n\n              '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) list[j++] = expr\n\n      }\n\n      expr = j < 2 ? list[0] :\n             '[' + list.join(',') + '].join(\"\")'\n    }\n    else {\n\n      expr = _parseExpr(parts[1], 0, qstr)\n    }\n\n    if (qstr[0])\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      })\n\n    return expr\n  }\n\n  var\n    CS_IDENT = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\x01(\\d+)~):/,\n    RE_BRACE = /,|([[{(])|$/g\n\n  function _parseExpr(expr, asText, qstr) {\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? '\\x01' + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match\n\n      while (expr &&\n            (match = expr.match(CS_IDENT)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g\n\n        expr = RegExp.rightContext\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\n        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\n        jsb  = expr.slice(0, match.index)\n        expr = RegExp.rightContext\n\n        list[cnt++] = _wrapExpr(jsb, 1, key)\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText) :\n          cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n    }\n    return expr\n\n    function skipBraces(jsb, re) {\n      var\n        match,\n        lv = 1,\n        ir = jsb === '(' ? /[()]/g : jsb === '[' ? /[[\\]]/g : /[{}]/g\n\n      ir.lastIndex = re.lastIndex\n      while (match = ir.exec(expr)) {\n        if (match[0] === jsb) ++lv\n        else if (!--lv) break\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex\n    }\n  }\n\n  // istanbul ignore next: not both\n  var JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').'\n  var JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g\n\n  function _wrapExpr(expr, asText, key) {\n    var tb = FALSE\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n        }\n        else if (pos)\n          tb = !/^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/.test(s.slice(pos))\n      }\n      return match\n    })\n\n    if (tb) {\n      expr = \"try{return \" + expr + '}catch(e){E(e,this)}'\n    }\n\n    if (key) {\n\n      expr = (tb ?\n          'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"'\n    }\n    else if (asText) {\n\n      expr = 'function(v){' + (tb ?\n          expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)'\n    }\n\n    return expr\n  }\n\n  // istanbul ignore next: compatibility fix for beta versions\n  _tmpl.parse = function (s) { return s }\n\n  return _tmpl\n\n})()\n\n\n/*\n  lib/browser/tag/mkdom.js\n\n  Includes hacks needed for the Internet Explorer version 9 and bellow\n\n*/\n// http://kangax.github.io/compat-table/es5/#ie8\n// http://codeplanet.io/dropping-ie8/\n\nvar mkdom = (function (checkIE) {\n\n  var rootEls = {\n      'tr': 'tbody',\n      'th': 'tr',\n      'td': 'tr',\n      'tbody': 'table',\n      'col': 'colgroup'\n    },\n    GENERIC = 'div'\n\n  checkIE = checkIE && checkIE < 10\n\n  // creates any dom element in a div, table, or colgroup container\n  function _mkdom(html) {\n\n    var match = html && html.match(/^\\s*<([-\\w]+)/),\n      tagName = match && match[1].toLowerCase(),\n      rootTag = rootEls[tagName] || GENERIC,\n      el = mkEl(rootTag)\n\n    el.stub = true\n\n    /* istanbul ignore next */\n    if (checkIE && tagName && (match = tagName.match(SPECIAL_TAGS_REGEX)))\n      ie9elem(el, html, tagName, !!match[1])\n    else\n      el.innerHTML = html\n\n    return el\n  }\n\n  // creates tr, th, td, option, optgroup element for IE8-9\n  /* istanbul ignore next */\n  function ie9elem(el, html, tagName, select) {\n\n    var div = mkEl(GENERIC),\n      tag = select ? 'select>' : 'table>',\n      child\n\n    div.innerHTML = '<' + tag + html + '</' + tag\n\n    child = $(tagName, div)\n    if (child)\n      el.appendChild(child)\n\n  }\n  // end ie9elem()\n\n  return _mkdom\n\n})(IE_VERSION)\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n\n  var i = tags.length,\n    j = items.length\n\n  while (i > j) {\n    var t = tags[--i]\n    tags.splice(i, 1)\n    t.unmount()\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @param   { Object } child - non custom loop tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(child, i) {\n  Object.keys(child.tags).forEach(function(tagName) {\n    var tag = child.tags[tagName]\n    if (isArray(tag))\n      each(tag, function (t) {\n        moveChildTag(t, tagName, i)\n      })\n    else\n      moveChildTag(tag, tagName, i)\n  })\n}\n\n/**\n * Adds the elements for a virtual tag\n * @param { Tag } tag - the tag whose root's children will be inserted or appended\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction addVirtual(tag, src, target) {\n  var el = tag._root\n  tag._virts = []\n  while (el) {\n    var sib = el.nextSibling\n    if (target)\n      src.insertBefore(el, target._root)\n    else\n      src.appendChild(el)\n\n    tag._virts.push(el) // hold for unmounting\n    el = sib\n  }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @param { Tag } tag - first child reference used to start move\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n * @param { Number } len - how many child nodes to move\n */\nfunction moveVirtual(tag, src, target, len) {\n  var el = tag._root\n  for (var i = 0; i < len; i++) {\n    var sib = el.nextSibling\n    src.insertBefore(el, target._root)\n    el = sib\n  }\n}\n\n\n/**\n * Manage tags having the 'each'\n * @param   { Object } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each')\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __tagImpl[tagName] || { tmpl: dom.outerHTML },\n    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n    root = dom.parentNode,\n    isSpecialTag = SPECIAL_TAGS_REGEX.test(tagName),\n    ref = document.createTextNode(''),\n    child = getTag(dom),\n    tags = [],\n    oldItems = [],\n    checksum,\n    isVirtual = dom.tagName == 'VIRTUAL'\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr)\n\n  // insert a marked where the loop tags will be injected\n  root.insertBefore(ref, dom)\n\n  // clean template code\n  parent.one('before-mount', function () {\n\n    // remove the original DOM node\n    dom.parentNode.removeChild(dom)\n    if (root.stub) root = parent.root\n\n  }).on('update', function () {\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      // create a fragment to hold the new DOM nodes to inject in the parent tag\n      frag = document.createDocumentFragment()\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      checksum = items ? JSON.stringify(items) : ''\n      items = !items ? [] :\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, key, items[key])\n        })\n    }\n\n    // loop all the new items\n    each(items, function(item, i) {\n      // reorder only if the items are objects\n      var _mustReorder = mustReorder && item instanceof Object,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos]\n\n      item = !checksum && expr.key ? mkitem(expr, item, i) : item\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n      ) {\n\n        tag = new Tag(impl, {\n          parent: parent,\n          isLoop: true,\n          hasImpl: !!__tagImpl[tagName],\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML)\n\n        tag.mount()\n        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n        // this tag must be appended\n        if (i == tags.length) {\n          if (isVirtual)\n            addVirtual(tag, frag)\n          else frag.appendChild(tag.root)\n        }\n        // this tag must be insert\n        else {\n          if (isVirtual)\n            addVirtual(tag, root, tags[i])\n          else root.insertBefore(tag.root, tags[i].root)\n          oldItems.splice(i, 0, item)\n        }\n\n        tags.splice(i, 0, tag)\n        pos = i // handled here so no move\n      } else tag.update(item)\n\n      // reorder the tag if it's not located in its previous position\n      if (pos !== i && _mustReorder) {\n        // update the DOM\n        if (isVirtual)\n          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n        else root.insertBefore(tag.root, tags[i].root)\n        // update the position attribute if it exists\n        if (expr.pos)\n          tag[expr.pos] = i\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0])\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child) moveNestedTags(tag, i)\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent)\n\n    })\n\n    // remove the redundant tags\n    unmountRedundant(items, tags)\n\n    // insert the new nodes\n    if (isSpecialTag) root.appendChild(frag)\n    else root.insertBefore(frag, ref)\n\n    // set the 'tags' property of the parent tag\n    // if child is 'undefined' it means that we don't need to set this property\n    // for example:\n    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n    if (child) parent.tags[tagName] = tags\n\n    // clone the items array\n    oldItems = items.slice()\n\n  })\n\n}\n\n\nfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each')) ? 1 : 0\n\n      // custom child tag\n      if (childTags) {\n        var child = getTag(dom)\n\n        if (child && !dom.isLoop)\n          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n      }\n\n      if (!dom.isLoop || forceParsingNamed)\n        setNamed(dom, tag, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (tmpl.hasExpr(val)) {\n      var expr = { dom: dom, expr: val }\n      expressions.push(extend(expr, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = getAttr(dom, 'each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n    opts = inherit(conf.opts) || {},\n    dom = mkdom(impl.tmpl),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    hasImpl = conf.hasImpl,\n    item = cleanUpData(conf.item),\n    expressions = [],\n    childTags = [],\n    root = conf.root,\n    fn = impl.fn,\n    tagName = root.tagName.toLowerCase(),\n    attr = {},\n    propsInSyncWithParent = []\n\n  if (fn && root._tag) root._tag.unmount(true)\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (tmpl.hasExpr(val)) attr[el.name] = val\n  })\n\n  if (dom.innerHTML && !/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(tagName))\n    // replace all the yield tags with the tag inner html\n    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      opts[toCamel(el.name)] = tmpl(el.value, ctx)\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[toCamel(name)] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFromParent () {\n    if (!self.parent || !isLoop) return\n    each(Object.keys(self.parent), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !contains(RESERVED_WORDS_BLACKLIST, k) && contains(propsInSyncWithParent, k)\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = self.parent[k]\n      }\n    })\n  }\n\n  defineProperty(this, 'update', function(data) {\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent\n    inheritFromParent()\n    // normalize the tag properties in case an item object was initially passed\n    if (data && typeof item === T_OBJECT) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n    self.trigger('updated')\n    return this\n  })\n\n  defineProperty(this, 'mixin', function() {\n    each(arguments, function(mix) {\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n      each(Object.keys(mix), function(key) {\n        // bind methods to self\n        if (key != 'init')\n          self[key] = isFunction(mix[key]) ? mix[key].bind(self) : mix[key]\n      })\n      // init method will be called automatically\n      if (mix.init) mix.init.bind(self)()\n    })\n    return this\n  })\n\n  defineProperty(this, 'mount', function() {\n\n    updateOpts()\n\n    // initialiation\n    if (fn) fn.call(self, opts)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    // mount the child tags\n    toggle(true)\n\n    // update the root adding custom attributes coming from the compiler\n    // it fixes also #1087\n    if (impl.attrs || hasImpl) {\n      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n      parseExpressions(self.root, self, expressions)\n    }\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('before-mount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      self.root = root = dom.firstChild\n\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) self.root = root = parent.root\n    }\n\n    // parse the named dom nodes in the looped child\n    // adding them to the parent as well\n    if (isLoop)\n      parseNamedElements(self.root, self.parent, null, true)\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  })\n\n\n  defineProperty(this, 'unmount', function(keepRootTag) {\n    var el = root,\n      p = el.parentNode,\n      ptag\n\n    self.trigger('before-unmount')\n\n    // remove this tag instance from the global virtualDom variable\n    __virtualDom.splice(__virtualDom.indexOf(self), 1)\n\n    if (this._virts) {\n      each(this._virts, function(v) {\n        v.parentNode.removeChild(v)\n      })\n    }\n\n    if (p) {\n\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(ptag.tags[tagName]))\n          each(ptag.tags[tagName], function(tag, i) {\n            if (tag._riot_id == self._riot_id)\n              ptag.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          ptag.tags[tagName] = undefined\n      }\n\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n      else\n        // the riot-tag attribute isn't needed anymore, remove it\n        remAttr(p, 'riot-tag')\n    }\n\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    self.isMounted = false\n    // somehow ie8 does not like `delete root._tag`\n    root._tag = null\n\n  })\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (parent) {\n      var evt = isMount ? 'on' : 'off'\n\n      // the loop tags will be always in sync with the parent automatically\n      if (isLoop)\n        parent[evt]('unmount', self.unmount)\n      else\n        parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n    }\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n}\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var ptag = tag._parent,\n      item = tag._item,\n      el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag._parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // override the event properties\n    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n    if (isWritable(e, 'target')) e.target = e.srcElement\n    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n\n  }\n\n}\n\n\n/**\n * Insert a DOM node replacing another one (used by if- attribute)\n * @param   { Object } root - parent node\n * @param   { Object } node - node replaced\n * @param   { Object } before - node added\n */\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\n/**\n * Update the expressions in a Tag instance\n * @param   { Array } expressions - expression that must be re evaluated\n * @param   { Tag } tag - tag instance\n */\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n      attrName = expr.attr,\n      value = tmpl(expr.expr, tag),\n      parent = expr.dom.parentNode\n\n    if (expr.bool)\n      value = value ? attrName : false\n    else if (value == null)\n      value = ''\n\n    // leave out riot- prefixes from strings inside textarea\n    // fix #815: any value -> string\n    if (parent && parent.tagName == 'TEXTAREA') value = ('' + value).replace(/riot-/g, '')\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attrName) {\n      dom.nodeValue = '' + value    // #815 related\n      return\n    }\n\n    // remove original attribute\n    remAttr(dom, attrName)\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub,\n        add = function() { insertTo(stub.parentNode, stub, dom) },\n        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          add()\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted) el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        // if the parentNode is defined we can easily replace the tag\n        if (dom.parentNode)\n          remove()\n        // otherwise we need to wait the updated event\n        else (tag.parent || tag).one('updated', remove)\n\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (/^(show|hide)$/.test(attrName)) {\n      if (attrName == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // field value\n    } else if (attrName == 'value') {\n      dom.value = value\n\n    // <img src=\"{ expr }\">\n    } else if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n      if (value)\n        setAttr(dom, attrName.slice(RIOT_PREFIX.length), value)\n\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value\n        if (!value) return\n      }\n\n      if (typeof value !== T_OBJECT) setAttr(dom, attrName, value)\n\n    }\n\n  })\n\n}\n/**\n * Loops an array\n * @param   { Array } els - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(els, fn) {\n  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n    el = els[i]\n    // return false -> remove current item during loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\n/**\n * Detect if the argument passed is a function\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isFunction(v) {\n  return typeof v === T_FUNCTION || false   // avoid IE problems\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\n/**\n * Convert a string containing dashes to camle case\n * @param   { String } string - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(string) {\n  return string.replace(/(\\-\\w)/g, function(match) {\n    return match.toUpperCase().replace('-', '')\n  })\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  dom.setAttribute(name, val)\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n}\n/**\n * Add a child tag to its parent into the `tags` object\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the new tag will be stored\n * @param   { Object } parent - tag instance where the new child tag will be included\n */\nfunction addChildTag(tag, tagName, parent) {\n  var cachedTag = parent.tags[tagName]\n\n  // if there are multiple children tags having the same name\n  if (cachedTag) {\n    // if the parent tags property is not yet an array\n    // create it adding the first cached tag\n    if (!isArray(cachedTag))\n      // don't add the same tag twice\n      if (cachedTag !== tag)\n        parent.tags[tagName] = [cachedTag]\n    // add the new nested tag to the array\n    if (!contains(parent.tags[tagName], tag))\n      parent.tags[tagName].push(tag)\n  } else {\n    parent.tags[tagName] = tag\n  }\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tag, tagName, newPos) {\n  var parent = tag.parent,\n    tags\n  // no parent no move\n  if (!parent) return\n\n  tags = parent.tags[tagName]\n\n  if (isArray(tags))\n    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n  else addChildTag(tag, tagName, parent)\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag(child, opts, innerHTML),\n    tagName = getTagName(opts.root),\n    ptag = getImmediateCustomParentTag(parent)\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent\n\n  // add this tag to the custom parent tag\n  addChildTag(tag, tagName, ptag)\n  // and also to the real parent tag\n  if (ptag !== parent)\n    addChildTag(tag, tagName, parent)\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = ''\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag\n  while (!getTag(ptag.root)) {\n    if (!ptag.parent) break\n    ptag = ptag.parent\n  }\n  return ptag\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n* @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: false\n  }, options))\n  return el\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = getAttr(dom, 'name'),\n    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } arr - target array\n * @param   { * } item - item to test\n * @returns { Boolean } Does 'arr' contain 'item'?\n */\nfunction contains(arr, item) {\n  return ~arr.indexOf(item)\n}\n\n/**\n * Check whether an object is a kind of array\n * @param   { * } a - anything\n * @returns {Boolean} is 'a' an array?\n */\nfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\n/**\n * Detect whether a property of an object could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } is this property writable?\n */\nfunction isWritable(obj, key) {\n  var props = Object.getOwnPropertyDescriptor(obj, key)\n  return typeof obj[key] === T_UNDEF || props && props.writable\n}\n\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION)) return data\n\n  var o = {}\n  for (var key in data) {\n    if (!contains(RESERVED_WORDS_BLACKLIST, key))\n      o[key] = data[key]\n  }\n  return o\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n */\nfunction walk(dom, fn) {\n  if (dom) {\n    // stop the recursion\n    if (fn(dom) === false) return\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  var m,\n    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\n  while (m = re.exec(html)) {\n    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n  }\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\n/**\n * Replace the yield tag from any tag template with the innerHTML of the\n * original tag in the page\n * @param   { String } tmpl - tag implementation template\n * @param   { String } innerHTML - original content of the tag in the DOM\n * @returns { String } tag template updated without the yield tag\n */\nfunction replaceYield(tmpl, innerHTML) {\n  return tmpl.replace(/<(yield)\\/?>(<\\/\\1>)?/gi, innerHTML || '')\n}\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Simple object prototypal inheritance\n * @param   { Object } parent - parent object\n * @returns { Object } child instance\n */\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\n/**\n * Get the name property needed to identify a DOM node in riot\n * @param   { Object } dom - DOM node we need to parse\n * @returns { String | undefined } give us back a string to identify this dom node\n */\nfunction getNamedKey(dom) {\n  return getAttr(dom, 'id') || getAttr(dom, 'name')\n}\n\n/**\n * Set the named properties of a tag element\n * @param { Object } dom - DOM node we need to parse\n * @param { Object } parent - tag instance where the named dom element will be eventually added\n * @param { Array } keys - list of all the tag instance properties\n */\nfunction setNamed(dom, parent, keys) {\n  // get the key value we want to add to the tag instance\n  var key = getNamedKey(dom),\n    // add the node detected to a tag instance using the named property\n    add = function(value) {\n      // avoid to override the tag properties already set\n      if (contains(keys, key)) return\n      // check whether this value is an array\n      var isArr = isArray(value)\n      // if the key was never set\n      if (!value)\n        // set it once on the tag instance\n        parent[key] = dom\n      // if it was an array and not yet set\n      else if (!isArr || isArr && !contains(value, dom)) {\n        // add the dom node into the array\n        if (isArr)\n          value.push(dom)\n        else\n          parent[key] = [value, dom]\n      }\n    }\n\n  // skip the elements with no named properties\n  if (!key) return\n\n  // check whether this key has been already evaluated\n  if (tmpl.hasExpr(key))\n    // wait the first updated event only once\n    parent.one('updated', function() {\n      key = getNamedKey(dom)\n      add(parent[key])\n    })\n  else\n    add(parent[key])\n\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } src - source string\n * @param   { String } str - test string\n * @returns { Boolean } -\n */\nfunction startsWith(src, str) {\n  return src.slice(0, str.length) === str\n}\n\n/**\n * Function needed to inject in runtime the custom tags css\n */\nvar injectStyle = (function() {\n\n  if (!window) return // skip injection on the server\n\n  // create the style node\n  var styleNode = mkEl('style'),\n    placeholder = $('style[type=riot]')\n\n  setAttr(styleNode, 'type', 'text/css')\n\n  // inject the new node into the DOM -- in head\n  if (placeholder) {\n    placeholder.parentNode.replaceChild(styleNode, placeholder)\n    placeholder = null\n  }\n  else document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  /**\n   * This is the function exported that will be used to update the style tag just created\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @param   { String } css [description]\n   */\n  return styleNode.styleSheet ?\n    function (css) { styleNode.styleSheet.cssText += css } :\n    function (css) { styleNode.innerHTML += css }\n\n})()\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts) {\n  var tag = __tagImpl[tagName],\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    // add this tag to the virtualDom variable\n    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n  }\n\n  return tag\n}\n/**\n * Riot public api\n */\n\n// share methods for other riot parts, e.g. compiler\nriot.util = { brackets: brackets, tmpl: tmpl }\n\n/**\n * Create a mixin that could be globally shared across all the tags\n */\nriot.mixin = (function() {\n  var mixins = {}\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String } name - mixin name\n   * @param   { Object } mixin - mixin logic\n   * @returns { Object } the mixin logic\n   */\n  return function(name, mixin) {\n    if (!mixin) return mixins[name]\n    mixins[name] = mixin\n  }\n\n})()\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else if (injectStyle) injectStyle(css)\n  }\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @param   { string }  [bpair] - brackets used in the compilation\n * @returns { String } name/id of the tag just created\n */\nriot.tag2 = function(name, html, css, attrs, fn, bpair) {\n  if (css && injectStyle) injectStyle(css)\n  //if (bpair) riot.settings.brackets = bpair\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { String } selector - tag DOM selector\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n    allTags,\n    tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      list += ', *[' + RIOT_TAG + '=\"' + e.trim() + '\"]'\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(__tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    var last\n\n    if (root.tagName) {\n      if (tagName && (!(last = getAttr(root, RIOT_TAG)) || last != tagName))\n        setAttr(root, RIOT_TAG, tagName)\n\n      var tag = mountTo(root, tagName || root.getAttribute(RIOT_TAG) || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    } else if (root.length)\n      each(root, pushTags)   // assume nodeList\n\n  }\n\n  // ----- mount code -----\n\n  if (typeof tagName === T_OBJECT) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(','))\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    els = selector ? $$(selector) : []\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  if (els.tagName)\n    pushTags(els)\n  else\n    each(els, pushTags)\n\n  return tags\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nriot.update = function() {\n  return each(__virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n/**\n * Export the Tag constructor\n */\nriot.Tag = Tag\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return (window.riot = riot) })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : void 0);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/riot/riot.js\n ** module id = 1\n ** module chunks = 0\n **/","import stream from 'most'\nimport bus from './bus'\nimport split from './split'\n\n/*\nCore:\n  signal-stream: pluggable stream of signals\n  side-stream: stream of side-effects\n\nProcessor: (state, signal) -> [state, effects]\nSignal(er?): () -> signal\nDetector: event -> signals\nEffector: effect -> [Promise(signal)]\nRenderer: state -> view\n*/\n\nfunction collect(acc, more) {\n  return more ? (acc || []).concat(more) : acc\n}\n\nfunction processSignal(processors) {\n  return function([state], signal) {\n    let reduction = processors.reduce(\n      ([state, effects], app) => {\n        let [s, e] = app(state, signal),\n            res = [ s, collect(effects, e) ]\n        return res\n      }, [state])\n    return reduction\n  }\n}\n\nfunction processEffect(effect, effectors) {\n  return stream.from(effectors)\n    .map(f => f(effect))\n    .chain(l => stream.from(l))\n    .map(i => Promise.resolve(i))\n    .await()\n}\n\nfunction loader(state, signal) {\n  if (signal.type == 'lupin.load') {\n    return [signal.state]\n  }\n  return [state]\n}\n\nfunction Lupin(initialState) {\n  let processors = [loader],\n      effectors = [],\n      signals = bus(),\n      merged = signals.scan(processSignal(processors),\n                            [initialState]),\n      [state, effects] = split(merged),\n\n      lupin = {\n        processors, signals, state, effectors,\n        effects: effects\n          .filter(e => e !== undefined)\n          .chain(l => stream.from(l))\n          .multicast(),\n\n        register(app) {\n          this.processors.push(app)\n        },\n\n        load(state) {\n          this.signals.push({type: 'lupin.load', state})\n        }\n      },\n      processedEffects = lupin.effects\n      .chain(e => processEffect(e, effectors))\n\n  lupin.signals.plug(processedEffects)\n  return lupin\n}\n\nexport default Lupin\nexport {Lupin, stream}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lupin/src/lupin.js\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('./lib/Stream');\nvar base = require('./lib/base');\nvar core = require('./lib/source/core');\nvar from = require('./lib/source/from').from;\nvar periodic = require('./lib/source/periodic').periodic;\n\n/**\n * Core stream type\n * @type {Stream}\n */\nexports.Stream = Stream;\n\n// Add of and empty to constructor for fantasy-land compat\nexports.of       = Stream.of    = core.of;\nexports.just     = core.of; // easier ES6 import alias\nexports.empty    = Stream.empty = core.empty;\nexports.never    = core.never;\nexports.from     = from;\nexports.periodic = periodic;\n\n//-----------------------------------------------------------------------\n// Creating\n\nvar create = require('./lib/source/create');\n\n/**\n * Create a stream by imperatively pushing events.\n * @param {function(add:function(x), end:function(e)):function} run function\n *  that will receive 2 functions as arguments, the first to add new values to the\n *  stream and the second to end the stream. It may *return* a function that\n *  will be called once all consumers have stopped observing the stream.\n * @returns {Stream} stream containing all events added by run before end\n */\nexports.create = create.create;\n\n//-----------------------------------------------------------------------\n// Adapting other sources\n\nvar events = require('./lib/source/fromEvent');\n\n/**\n * Create a stream of events from the supplied EventTarget or EventEmitter\n * @param {String} event event name\n * @param {EventTarget|EventEmitter} source EventTarget or EventEmitter. The source\n *  must support either addEventListener/removeEventListener (w3c EventTarget:\n *  http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget),\n *  or addListener/removeListener (node EventEmitter: http://nodejs.org/api/events.html)\n * @returns {Stream} stream of events of the specified type from the source\n */\nexports.fromEvent = events.fromEvent;\n\n//-----------------------------------------------------------------------\n// Lifting functions\n\nvar lift = require('./lib/combinator/lift').lift;\n\n/**\n * Lift a function that accepts values and returns a value, and return a function\n * that accepts streams and returns a stream.\n * @type {function(f:function(...args):*):function(...streams):Stream<*>}\n */\nexports.lift = lift;\n\n//-----------------------------------------------------------------------\n// Observing\n\nvar observe = require('./lib/combinator/observe');\n\nexports.observe = observe.observe;\nexports.forEach = observe.observe;\nexports.drain   = observe.drain;\n\n/**\n * Process all the events in the stream\n * @returns {Promise} promise that fulfills when the stream ends, or rejects\n *  if the stream fails with an unhandled error.\n */\nStream.prototype.observe = Stream.prototype.forEach = function(f) {\n\treturn observe.observe(f, this);\n};\n\n/**\n * Consume all events in the stream, without providing a function to process each.\n * This causes a stream to become active and begin emitting events, and is useful\n * in cases where all processing has been setup upstream via other combinators, and\n * there is no need to process the terminal events.\n * @returns {Promise} promise that fulfills when the stream ends, or rejects\n *  if the stream fails with an unhandled error.\n */\nStream.prototype.drain = function() {\n\treturn observe.drain(this);\n};\n\n//-------------------------------------------------------\n\nvar loop = require('./lib/combinator/loop').loop;\n\nexports.loop = loop;\n\n/**\n * Generalized feedback loop. Call a stepper function for each event. The stepper\n * will be called with 2 params: the current seed and the an event value.  It must\n * return a new { seed, value } pair. The `seed` will be fed back into the next\n * invocation of stepper, and the `value` will be propagated as the event value.\n * @param {function(seed:*, value:*):{seed:*, value:*}} stepper loop step function\n * @param {*} seed initial seed value passed to first stepper call\n * @returns {Stream} new stream whose values are the `value` field of the objects\n * returned by the stepper\n */\nStream.prototype.loop = function(stepper, seed) {\n\treturn loop(stepper, seed, this);\n};\n\n//-------------------------------------------------------\n\nvar accumulate = require('./lib/combinator/accumulate');\n\nexports.scan   = accumulate.scan;\nexports.reduce = accumulate.reduce;\n\n/**\n * Create a stream containing successive reduce results of applying f to\n * the previous reduce result and the current stream item.\n * @param {function(result:*, x:*):*} f reducer function\n * @param {*} initial initial value\n * @returns {Stream} new stream containing successive reduce results\n */\nStream.prototype.scan = function(f, initial) {\n\treturn accumulate.scan(f, initial, this);\n};\n\n/**\n * Reduce the stream to produce a single result.  Note that reducing an infinite\n * stream will return a Promise that never fulfills, but that may reject if an error\n * occurs.\n * @param {function(result:*, x:*):*} f reducer function\n * @param {*} initial optional initial value\n * @returns {Promise} promise for the file result of the reduce\n */\nStream.prototype.reduce = function(f, initial) {\n\treturn accumulate.reduce(f, initial, this);\n};\n\n//-----------------------------------------------------------------------\n// Building and extending\n\nvar unfold = require('./lib/source/unfold');\nvar iterate = require('./lib/source/iterate');\nvar generate = require('./lib/source/generate');\nvar build = require('./lib/combinator/build');\n\nexports.unfold    = unfold.unfold;\nexports.iterate   = iterate.iterate;\nexports.generate  = generate.generate;\nexports.concat    = build.cycle;\nexports.concat    = build.concat;\nexports.startWith = build.cons;\n\n/**\n * Tie this stream into a circle, thus creating an infinite stream\n * @returns {Stream} new infinite stream\n */\nStream.prototype.cycle = function() {\n\treturn build.cycle(this);\n};\n\n/**\n * @param {Stream} tail\n * @returns {Stream} new stream containing all items in this followed by\n *  all items in tail\n */\nStream.prototype.concat = function(tail) {\n\treturn build.concat(this, tail);\n};\n\n/**\n * @param {*} x value to prepend\n * @returns {Stream} a new stream with x prepended\n */\nStream.prototype.startWith = function(x) {\n\treturn build.cons(x, this);\n};\n\n//-----------------------------------------------------------------------\n// Transforming\n\nvar transform = require('./lib/combinator/transform');\nvar applicative = require('./lib/combinator/applicative');\n\nexports.map      = transform.map;\nexports.constant = transform.constant;\nexports.tap      = transform.tap;\nexports.ap       = applicative.ap;\n\n/**\n * Transform each value in the stream by applying f to each\n * @param {function(*):*} f mapping function\n * @returns {Stream} stream containing items transformed by f\n */\nStream.prototype.map = function(f) {\n\treturn transform.map(f, this);\n};\n\n/**\n * Assume this stream contains functions, and apply each function to each item\n * in the provided stream.  This generates, in effect, a cross product.\n * @param {Stream} xs stream of items to which\n * @returns {Stream} stream containing the cross product of items\n */\nStream.prototype.ap = function(xs) {\n\treturn applicative.ap(this, xs);\n};\n\n/**\n * Replace each value in the stream with x\n * @param {*} x\n * @returns {Stream} stream containing items replaced with x\n */\nStream.prototype.constant = function(x) {\n\treturn transform.constant(x, this);\n};\n\n/**\n * Perform a side effect for each item in the stream\n * @param {function(x:*):*} f side effect to execute for each item. The\n *  return value will be discarded.\n * @returns {Stream} new stream containing the same items as this stream\n */\nStream.prototype.tap = function(f) {\n\treturn transform.tap(f, this);\n};\n\n//-----------------------------------------------------------------------\n// Transducer support\n\nvar transduce = require('./lib/combinator/transduce');\n\nexports.transduce = transduce.transduce;\n\n/**\n * Transform this stream by passing its events through a transducer.\n * @param  {function} transducer transducer function\n * @return {Stream} stream of events transformed by the transducer\n */\nStream.prototype.transduce = function(transducer) {\n\treturn transduce.transduce(transducer, this);\n};\n\n//-----------------------------------------------------------------------\n// FlatMapping\n\nvar flatMap = require('./lib/combinator/flatMap');\n\nexports.flatMap = exports.chain = flatMap.flatMap;\nexports.join    = flatMap.join;\n\n/**\n * Map each value in the stream to a new stream, and merge it into the\n * returned outer stream. Event arrival times are preserved.\n * @param {function(x:*):Stream} f chaining function, must return a Stream\n * @returns {Stream} new stream containing all events from each stream returned by f\n */\nStream.prototype.flatMap = Stream.prototype.chain = function(f) {\n\treturn flatMap.flatMap(f, this);\n};\n\n/**\n * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner\n * streams to the outer. Event arrival times are preserved.\n * @returns {Stream<X>} new stream containing all events of all inner streams\n */\nStream.prototype.join = function() {\n\treturn flatMap.join(this);\n};\n\nvar flatMapEnd = require('./lib/combinator/flatMapEnd').flatMapEnd;\n\nexports.flatMapEnd = flatMapEnd;\n\n/**\n * Map the end event to a new stream, and begin emitting its values.\n * @param {function(x:*):Stream} f function that receives the end event value,\n * and *must* return a new Stream to continue with.\n * @returns {Stream} new stream that emits all events from the original stream,\n * followed by all events from the stream returned by f.\n */\nStream.prototype.flatMapEnd = function(f) {\n\treturn flatMapEnd(f, this);\n};\n\nvar concatMap = require('./lib/combinator/concatMap').concatMap;\n\nexports.concatMap = concatMap;\n\nStream.prototype.concatMap = function(f) {\n\treturn concatMap(f, this);\n};\n\n//-----------------------------------------------------------------------\n// Merging\n\nvar merge = require('./lib/combinator/merge');\n\nexports.merge = merge.merge;\n\n/**\n * Merge this stream and all the provided streams\n * @returns {Stream} stream containing items from this stream and s in time\n * order.  If two events are simultaneous they will be merged in\n * arbitrary order.\n */\nStream.prototype.merge = function(/*...streams*/) {\n\treturn merge.mergeArray(base.cons(this, arguments));\n};\n\n//-----------------------------------------------------------------------\n// Combining\n\nvar combine = require('./lib/combinator/combine');\n\nexports.combine = combine.combine;\n\n/**\n * Combine latest events from all input streams\n * @param {function(...events):*} f function to combine most recent events\n * @returns {Stream} stream containing the result of applying f to the most recent\n *  event of each input stream, whenever a new event arrives on any stream.\n */\nStream.prototype.combine = function(f /*, ...streams*/) {\n\treturn combine.combineArray(f, base.replace(this, 0, arguments));\n};\n\n//-----------------------------------------------------------------------\n// Sampling\n\nvar sample = require('./lib/combinator/sample');\n\nexports.sample = sample.sample;\nexports.sampleWith = sample.sampleWith;\n\n/**\n * When an event arrives on sampler, emit the latest event value from stream.\n * @param {Stream} sampler stream of events at whose arrival time\n *  signal's latest value will be propagated\n * @returns {Stream} sampled stream of values\n */\nStream.prototype.sampleWith = function(sampler) {\n\treturn sample.sampleWith(sampler, this);\n};\n\n/**\n * When an event arrives on this stream, emit the result of calling f with the latest\n * values of all streams being sampled\n * @param {function(...values):*} f function to apply to each set of sampled values\n * @returns {Stream} stream of sampled and transformed values\n */\nStream.prototype.sample = function(f /* ...streams */) {\n\treturn sample.sampleArray(f, this, base.tail(arguments));\n};\n\n//-----------------------------------------------------------------------\n// Zipping\n\nvar zip = require('./lib/combinator/zip');\n\nexports.zip = zip.zip;\n\n/**\n * Pair-wise combine items with those in s. Given 2 streams:\n * [1,2,3] zipWith f [4,5,6] -> [f(1,4),f(2,5),f(3,6)]\n * Note: zip causes fast streams to buffer and wait for slow streams.\n * @param {function(a:Stream, b:Stream, ...):*} f function to combine items\n * @returns {Stream} new stream containing pairs\n */\nStream.prototype.zip = function(f /*, ...streams*/) {\n\treturn zip.zipArray(f, base.replace(this, 0, arguments));\n};\n\n//-----------------------------------------------------------------------\n// Switching\n\nvar switchLatest = require('./lib/combinator/switch').switch;\n\nexports.switch       = switchLatest;\nexports.switchLatest = switchLatest;\n\n/**\n * Given a stream of streams, return a new stream that adopts the behavior\n * of the most recent inner stream.\n * @returns {Stream} switching stream\n */\nStream.prototype.switch = Stream.prototype.switchLatest = function() {\n\treturn switchLatest(this);\n};\n\n//-----------------------------------------------------------------------\n// Filtering\n\nvar filter = require('./lib/combinator/filter');\n\nexports.filter          = filter.filter;\nexports.skipRepeats     = exports.distinct   = filter.skipRepeats;\nexports.skipRepeatsWith = exports.distinctBy = filter.skipRepeatsWith;\n\n/**\n * Retain only items matching a predicate\n * stream:                           -12345678-\n * filter(x => x % 2 === 0, stream): --2-4-6-8-\n * @param {function(x:*):boolean} p filtering predicate called for each item\n * @returns {Stream} stream containing only items for which predicate returns truthy\n */\nStream.prototype.filter = function(p) {\n\treturn filter.filter(p, this);\n};\n\n/**\n * Skip repeated events, using === to compare items\n * stream:           -abbcd-\n * distinct(stream): -ab-cd-\n * @returns {Stream} stream with no repeated events\n */\nStream.prototype.skipRepeats = function() {\n\treturn filter.skipRepeats(this);\n};\n\n/**\n * Skip repeated events, using supplied equals function to compare items\n * @param {function(a:*, b:*):boolean} equals function to compare items\n * @returns {Stream} stream with no repeated events\n */\nStream.prototype.skipRepeatsWith = function(equals) {\n\treturn filter.skipRepeatsWith(equals, this);\n};\n\n//-----------------------------------------------------------------------\n// Slicing\n\nvar slice = require('./lib/combinator/slice');\n\nexports.take      = slice.take;\nexports.skip      = slice.skip;\nexports.slice     = slice.slice;\nexports.takeWhile = slice.takeWhile;\nexports.skipWhile = slice.skipWhile;\n\n/**\n * stream:          -abcd-\n * take(2, stream): -ab|\n * @param {Number} n take up to this many events\n * @returns {Stream} stream containing at most the first n items from this stream\n */\nStream.prototype.take = function(n) {\n\treturn slice.take(n, this);\n};\n\n/**\n * stream:          -abcd->\n * skip(2, stream): ---cd->\n * @param {Number} n skip this many events\n * @returns {Stream} stream not containing the first n events\n */\nStream.prototype.skip = function(n) {\n\treturn slice.skip(n, this);\n};\n\n/**\n * Slice a stream by event index. Equivalent to, but more efficient than\n * stream.take(end).skip(start);\n * NOTE: Negative start and end are not supported\n * @param {Number} start skip all events before the start index\n * @param {Number} end allow all events from the start index to the end index\n * @returns {Stream} stream containing items where start <= index < end\n */\nStream.prototype.slice = function(start, end) {\n\treturn slice.slice(start, end, this);\n};\n\n/**\n * stream:                        -123451234->\n * takeWhile(x => x < 5, stream): -1234|\n * @param {function(x:*):boolean} p predicate\n * @returns {Stream} stream containing items up to, but not including, the\n * first item for which p returns falsy.\n */\nStream.prototype.takeWhile = function(p) {\n\treturn slice.takeWhile(p, this);\n};\n\n/**\n * stream:                        -123451234->\n * skipWhile(x => x < 5, stream): -----51234->\n * @param {function(x:*):boolean} p predicate\n * @returns {Stream} stream containing items following *and including* the\n * first item for which p returns falsy.\n */\nStream.prototype.skipWhile = function(p) {\n\treturn slice.skipWhile(p, this);\n};\n\n//-----------------------------------------------------------------------\n// Time slicing\n\nvar timeslice = require('./lib/combinator/timeslice');\n\nexports.until  = exports.takeUntil = timeslice.takeUntil;\nexports.since  = exports.skipUntil = timeslice.skipUntil;\nexports.during = timeslice.during; // EXPERIMENTAL\n\n/**\n * stream:                    -a-b-c-d-e-f-g->\n * signal:                    -------x\n * takeUntil(signal, stream): -a-b-c-|\n * @param {Stream} signal retain only events in stream before the first\n * event in signal\n * @returns {Stream} new stream containing only events that occur before\n * the first event in signal.\n */\nStream.prototype.until = Stream.prototype.takeUntil = function(signal) {\n\treturn timeslice.takeUntil(signal, this);\n};\n\n/**\n * stream:                    -a-b-c-d-e-f-g->\n * signal:                    -------x\n * takeUntil(signal, stream): -------d-e-f-g->\n * @param {Stream} signal retain only events in stream at or after the first\n * event in signal\n * @returns {Stream} new stream containing only events that occur after\n * the first event in signal.\n */\nStream.prototype.since = Stream.prototype.skipUntil = function(signal) {\n\treturn timeslice.skipUntil(signal, this);\n};\n\n/**\n * stream:                    -a-b-c-d-e-f-g->\n * timeWindow:                -----s\n * s:                               -----t\n * stream.during(timeWindow): -----c-d-e-|\n * @param {Stream<Stream>} timeWindow a stream whose first event (s) represents\n *  the window start time.  That event (s) is itself a stream whose first event (t)\n *  represents the window end time\n * @returns {Stream} new stream containing only events within the provided timespan\n */\nStream.prototype.during = function(timeWindow) {\n\treturn timeslice.during(timeWindow, this);\n};\n\n//-----------------------------------------------------------------------\n// Delaying\n\nvar delay = require('./lib/combinator/delay').delay;\n\nexports.delay = delay;\n\n/**\n * @param {Number} delayTime milliseconds to delay each item\n * @returns {Stream} new stream containing the same items, but delayed by ms\n */\nStream.prototype.delay = function(delayTime) {\n\treturn delay(delayTime, this);\n};\n\n//-----------------------------------------------------------------------\n// Getting event timestamp\n\nvar timestamp = require('./lib/combinator/timestamp').timestamp;\n\nexports.timestamp = timestamp;\n\n/**\n * Expose event timestamps into the stream. Turns a Stream<X> into\n * Stream<{time:t, value:X}>\n * @returns {Stream<{time:number, value:*}>}\n */\nStream.prototype.timestamp = function() {\n\treturn timestamp(this);\n};\n\n//-----------------------------------------------------------------------\n// Rate limiting\n\nvar limit = require('./lib/combinator/limit');\n\nexports.throttle = limit.throttle;\nexports.debounce = limit.debounce;\n\n/**\n * Limit the rate of events\n * stream:              abcd----abcd----\n * throttle(2, stream): a-c-----a-c-----\n * @param {Number} period time to suppress events\n * @returns {Stream} new stream that skips events for throttle period\n */\nStream.prototype.throttle = function(period) {\n\treturn limit.throttle(period, this);\n};\n\n/**\n * Wait for a burst of events to subside and emit only the last event in the burst\n * stream:              abcd----abcd----\n * debounce(2, stream): -----d-------d--\n * @param {Number} period events occuring more frequently than this\n *  on the provided scheduler will be suppressed\n * @returns {Stream} new debounced stream\n */\nStream.prototype.debounce = function(period) {\n\treturn limit.debounce(period, this);\n};\n\n//-----------------------------------------------------------------------\n// Awaiting Promises\n\nvar promises = require('./lib/combinator/promises');\n\nexports.fromPromise = promises.fromPromise;\nexports.await       = promises.await;\n\n/**\n * Await promises, turning a Stream<Promise<X>> into Stream<X>.  Preserves\n * event order, but timeshifts events based on promise resolution time.\n * @returns {Stream<X>} stream containing non-promise values\n */\nStream.prototype.await = function() {\n\treturn promises.await(this);\n};\n\n//-----------------------------------------------------------------------\n// Error handling\n\nvar errors = require('./lib/combinator/errors');\n\nexports.flatMapError = errors.flatMapError;\nexports.throwError   = errors.throwError;\n\n/**\n * If this stream encounters an error, recover and continue with items from stream\n * returned by f.\n * stream:                  -a-b-c-X-\n * f(X):                           d-e-f-g-\n * flatMapError(f, stream): -a-b-c-d-e-f-g-\n * @param {function(error:*):Stream} f function which returns a new stream\n * @returns {Stream} new stream which will recover from an error by calling f\n */\nStream.prototype.flatMapError = function(f) {\n\treturn errors.flatMapError(f, this);\n};\n\n//-----------------------------------------------------------------------\n// Multicasting\n\nvar multicast = require('./lib/combinator/multicast').multicast;\n\nexports.multicast = multicast;\n\n/**\n * Transform the stream into multicast stream.  That means that many subscribers\n * to the stream will not cause multiple invocations of the internal machinery.\n * @returns {Stream} new stream which will multicast events to all observers.\n */\nStream.prototype.multicast = function() {\n\treturn multicast(this);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/most.js\n ** module id = 3\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nmodule.exports = Stream;\n\nfunction Stream(source) {\n\tthis.source = source;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/Stream.js\n ** module id = 4\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nexports.noop = noop;\nexports.identity = identity;\nexports.compose = compose;\n\nexports.cons = cons;\nexports.append = append;\nexports.drop = drop;\nexports.tail = tail;\nexports.copy = copy;\nexports.map = map;\nexports.reduce = reduce;\nexports.replace = replace;\nexports.remove = remove;\nexports.removeAll = removeAll;\nexports.findIndex = findIndex;\n\nfunction noop() {}\n\nfunction identity(x) {\n\treturn x;\n}\n\nfunction compose(f, g) {\n\treturn function(x) {\n\t\treturn f(g(x));\n\t};\n}\n\nfunction cons(x, array) {\n\tvar l = array.length;\n\tvar a = new Array(l + 1);\n\ta[0] = x;\n\tfor(var i=0; i<l; ++i) {\n\t\ta[i + 1] = array[i];\n\t}\n\treturn a;\n}\n\nfunction append(x, a) {\n\tvar l = a.length;\n\tvar b = new Array(l+1);\n\tfor(var i=0; i<l; ++i) {\n\t\tb[i] = a[i];\n\t}\n\n\tb[l] = x;\n\treturn b;\n}\n\nfunction drop(n, array) {\n\tvar l = array.length;\n\tif(n >= l) {\n\t\treturn [];\n\t}\n\n\tl -= n;\n\tvar a = new Array(l);\n\tfor(var i=0; i<l; ++i) {\n\t\ta[i] = array[n+i];\n\t}\n\treturn a;\n}\n\nfunction tail(array) {\n\treturn drop(1, array);\n}\n\nfunction copy(array) {\n\tvar l = array.length;\n\tvar a = new Array(l);\n\tfor(var i=0; i<l; ++i) {\n\t\ta[i] = array[i];\n\t}\n\treturn a;\n}\n\nfunction map(f, array) {\n\tvar l = array.length;\n\tvar a = new Array(l);\n\tfor(var i=0; i<l; ++i) {\n\t\ta[i] = f(array[i]);\n\t}\n\treturn a;\n}\n\nfunction reduce(f, z, array) {\n\tvar r = z;\n\tfor(var i=0, l=array.length; i<l; ++i) {\n\t\tr = f(r, array[i], i);\n\t}\n\treturn r;\n}\n\nfunction replace(x, i, array) {\n\tvar l = array.length;\n\tvar a = new Array(l);\n\tfor(var j=0; j<l; ++j) {\n\t\ta[j] = i === j ? x : array[j];\n\t}\n\treturn a;\n}\n\nfunction remove(index, array) {\n\tvar l = array.length;\n\tif(index >= array) { // exit early if index beyond end of array\n\t\treturn array;\n\t}\n\n\tif(l === 1) { // exit early if index in bounds and length === 1\n\t\treturn [];\n\t}\n\n\tl -= 1;\n\tvar b = new Array(l);\n\tvar i;\n\tfor(i=0; i<index; ++i) {\n\t\tb[i] = array[i];\n\t}\n\tfor(i=index; i<l; ++i) {\n\t\tb[i] = array[i+1];\n\t}\n\n\treturn b;\n}\n\nfunction removeAll(f, a) {\n\tvar l = a.length;\n\tvar b = new Array(l);\n\tfor(var x, i=0, j=0; i<l; ++i) {\n\t\tx = a[i];\n\t\tif(!f(x)) {\n\t\t\tb[j] = x;\n\t\t\t++j;\n\t\t}\n\t}\n\n\tb.length = j;\n\treturn b;\n}\n\nfunction findIndex(x, a) {\n\tfor (var i = 0, l = a.length; i < l; ++i) {\n\t\tif (x === a[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/base.js\n ** module id = 5\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar ValueSource = require('../source/ValueSource');\nvar Disposable = require('../disposable/Disposable');\nvar EmptyDisposable = require('../disposable/EmptyDisposable');\nvar PropagateTask = require('../scheduler/PropagateTask');\n\nexports.of = streamOf;\nexports.empty = empty;\nexports.never = never;\n\n/**\n * Stream containing only x\n * @param {*} x\n * @returns {Stream}\n */\nfunction streamOf(x) {\n\treturn new Stream(new ValueSource(emit, x));\n}\n\nfunction emit(t, x, sink) {\n\tsink.event(0, x);\n\tsink.end(0, void 0);\n}\n\n/**\n * Stream containing no events and ends immediately\n * @returns {Stream}\n */\nfunction empty() {\n\treturn EMPTY;\n}\n\nfunction EmptySource() {}\n\nEmptySource.prototype.run = function(sink, scheduler) {\n\tvar task = PropagateTask.end(void 0, sink);\n\tscheduler.asap(task);\n\n\treturn new Disposable(dispose, task);\n};\n\nfunction dispose(task) {\n\treturn task.dispose();\n}\n\nvar EMPTY = new Stream(new EmptySource());\n\n/**\n * Stream containing no events and never ends\n * @returns {Stream}\n */\nfunction never() {\n\treturn NEVER;\n}\n\nfunction NeverSource() {}\n\nNeverSource.prototype.run = function() {\n\treturn new EmptyDisposable();\n};\n\nvar NEVER = new Stream(new NeverSource());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/core.js\n ** module id = 6\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar PropagateTask = require('../scheduler/PropagateTask');\n\nmodule.exports = ValueSource;\n\nfunction ValueSource(emit, x) {\n\tthis.emit = emit;\n\tthis.value = x;\n}\n\nValueSource.prototype.run = function(sink, scheduler) {\n\treturn new ValueProducer(this.emit, this.value, sink, scheduler);\n};\n\nfunction ValueProducer(emit, x, sink, scheduler) {\n\tthis.task = new PropagateTask(emit, x, sink);\n\tscheduler.asap(this.task);\n}\n\nValueProducer.prototype.dispose = function() {\n\treturn this.task.dispose();\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/ValueSource.js\n ** module id = 7\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar fatal = require('../fatalError');\n\nmodule.exports = PropagateTask;\n\nfunction PropagateTask(run, value, sink) {\n\tthis._run = run;\n\tthis.value = value;\n\tthis.sink = sink;\n\tthis.active = true;\n}\n\nPropagateTask.event = function(value, sink) {\n\treturn new PropagateTask(emit, value, sink);\n};\n\nPropagateTask.end = function(value, sink) {\n\treturn new PropagateTask(end, value, sink);\n};\n\nPropagateTask.error = function(value, sink) {\n\treturn new PropagateTask(error, value, sink);\n};\n\nPropagateTask.prototype.dispose = function() {\n\tthis.active = false;\n};\n\nPropagateTask.prototype.run = function(t) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\tthis._run(t, this.value, this.sink);\n};\n\nPropagateTask.prototype.error = function(t, e) {\n\tif(!this.active) {\n\t\treturn fatal(e);\n\t}\n\tthis.sink.error(t, e);\n};\n\nfunction error(t, e, sink) {\n\tsink.error(t, e);\n}\n\nfunction emit(t, x, sink) {\n\tsink.event(t, x);\n}\n\nfunction end(t, x, sink) {\n\tsink.end(t, x);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/scheduler/PropagateTask.js\n ** module id = 8\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nmodule.exports = fatalError;\n\nfunction fatalError (e) {\n\tsetTimeout(function() {\n\t\tthrow e;\n\t}, 0);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/fatalError.js\n ** module id = 9\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nmodule.exports = Disposable;\n\nfunction Disposable(f, data) {\n\tthis.disposed = false;\n\tthis._dispose = f;\n\tthis._data = data;\n}\n\nDisposable.prototype.dispose = function() {\n\tif(this.disposed) {\n\t\treturn;\n\t}\n\tthis.disposed = true;\n\treturn this._dispose(this._data);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/disposable/Disposable.js\n ** module id = 10\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar noop = require('../base').noop;\n\nmodule.exports = EmptyDisposable;\n\nfunction EmptyDisposable() {}\n\nEmptyDisposable.prototype.dispose = noop;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/disposable/EmptyDisposable.js\n ** module id = 11\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar fromArray = require('./fromArray').fromArray;\nvar isIterable = require('../iterable').isIterable;\nvar fromIterable = require('./fromIterable').fromIterable;\n\nexports.from = from;\n\nfunction from(a) {\n\tif(Array.isArray(a)) {\n\t\treturn fromArray(a);\n\t}\n\n\tif(isIterable(a)) {\n\t\treturn fromIterable(a);\n\t}\n\n\tthrow new TypeError('not iterable: ' + a);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/from.js\n ** module id = 12\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar PropagateTask = require('../scheduler/PropagateTask');\n\nexports.fromArray = fromArray;\n\nfunction fromArray (a) {\n\treturn new Stream(new ArraySource(a));\n}\n\nfunction ArraySource(a) {\n\tthis.array = a;\n}\n\nArraySource.prototype.run = function(sink, scheduler) {\n\treturn new ArrayProducer(this.array, sink, scheduler);\n};\n\nfunction ArrayProducer(array, sink, scheduler) {\n\tthis.scheduler = scheduler;\n\tthis.task = new PropagateTask(runProducer, array, sink);\n\tscheduler.asap(this.task);\n}\n\nArrayProducer.prototype.dispose = function() {\n\treturn this.task.dispose();\n};\n\nfunction runProducer(t, array, sink) {\n\treturn produce(this, array, sink, 0);\n}\n\nfunction produce(task, array, sink, k) {\n\tfor(var i=k, l=array.length; i<l && task.active; ++i) {\n\t\tsink.event(0, array[i]);\n\t}\n\n\treturn end();\n\n\tfunction end() {\n\t\treturn task.active && sink.end(0);\n\t}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/fromArray.js\n ** module id = 13\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nexports.isIterable = isIterable;\nexports.getIterator = getIterator;\nexports.makeIterable = makeIterable;\n\n/*global Set, Symbol*/\nvar iteratorSymbol;\n// Firefox ships a partial implementation using the name @@iterator.\n// https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14\nif (typeof Set === 'function' && typeof new Set()['@@iterator'] === 'function') {\n\titeratorSymbol = '@@iterator';\n} else {\n\titeratorSymbol = typeof Symbol === 'function' && Symbol.iterator ||\n\t'_es6shim_iterator_';\n}\n\nfunction isIterable(o) {\n\treturn typeof o[iteratorSymbol] === 'function';\n}\n\nfunction getIterator(o) {\n\treturn o[iteratorSymbol]();\n}\n\nfunction makeIterable(f, o) {\n\to[iteratorSymbol] = f;\n\treturn o;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/iterable.js\n ** module id = 14\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar getIterator = require('../iterable').getIterator;\nvar PropagateTask = require('../scheduler/PropagateTask');\n\nexports.fromIterable = fromIterable;\n\nfunction fromIterable(iterable) {\n\treturn new Stream(new IterableSource(iterable));\n}\n\nfunction IterableSource(iterable) {\n\tthis.iterable = iterable;\n}\n\nIterableSource.prototype.run = function(sink, scheduler) {\n\treturn new IteratorProducer(getIterator(this.iterable), sink, scheduler);\n};\n\nfunction IteratorProducer(iterator, sink, scheduler) {\n\tthis.scheduler = scheduler;\n\tthis.iterator = iterator;\n\tthis.task = new PropagateTask(runProducer, this, sink);\n\tscheduler.asap(this.task);\n}\n\nIteratorProducer.prototype.dispose = function() {\n\treturn this.task.dispose();\n};\n\nfunction runProducer(t, producer, sink) {\n\tvar x = producer.iterator.next();\n\tif(x.done) {\n\t\tsink.end(t, x.value);\n\t} else {\n\t\tsink.event(t, x.value);\n\t}\n\n\tproducer.scheduler.asap(producer.task);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/fromIterable.js\n ** module id = 15\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Disposable = require('../disposable/Disposable');\nvar MulticastSource = require('./MulticastSource');\nvar PropagateTask = require('../scheduler/PropagateTask');\n\nexports.periodic = periodic;\n\n/**\n * Create a stream that emits the current time periodically\n * @param {Number} period periodicity of events in millis\n * @param {*) value value to emit each period\n * @returns {Stream} new stream that emits the current time every period\n */\nfunction periodic(period, value) {\n\treturn new Stream(new MulticastSource(new Periodic(period, value)));\n}\n\nfunction Periodic(period, value) {\n\tthis.period = period;\n\tthis.value = value;\n}\n\nPeriodic.prototype.run = function(sink, scheduler) {\n\tvar task = scheduler.periodic(this.period, new PropagateTask(emit, this.value, sink));\n\treturn new Disposable(cancelTask, task);\n};\n\nfunction cancelTask(task) {\n\ttask.cancel();\n}\n\nfunction emit(t, x, sink) {\n\tsink.event(t, x);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/periodic.js\n ** module id = 16\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar base = require('../base');\nvar resolve = require('../Promise').resolve;\n\nmodule.exports = MulticastSource;\n\nfunction MulticastSource(source) {\n\tthis.source = source;\n\tthis.sink = new MulticastSink();\n\tthis._disposable = void 0;\n}\n\nMulticastSource.prototype.run = function(sink, scheduler) {\n\tvar n = this.sink.add(sink);\n\tif(n === 1) {\n\t\tthis._disposable = this.source.run(this.sink, scheduler);\n\t}\n\n\treturn new MulticastDisposable(this, sink);\n};\n\nMulticastSource.prototype._dispose = function() {\n\treturn resolve(this._disposable).then(dispose);\n};\n\nfunction dispose(disposable) {\n\tif(disposable === void 0) {\n\t\treturn;\n\t}\n\treturn disposable.dispose();\n}\n\nfunction MulticastDisposable(source, sink) {\n\tthis.source = source;\n\tthis.sink = sink;\n}\n\nMulticastDisposable.prototype.dispose = function() {\n\tvar s = this.source;\n\tvar remaining = s.sink.remove(this.sink);\n\treturn remaining === 0 && s._dispose();\n};\n\nfunction MulticastSink() {\n\tthis.sinks = [];\n}\n\nMulticastSink.prototype.add = function(sink) {\n\tthis.sinks = base.append(sink, this.sinks);\n\treturn this.sinks.length;\n};\n\nMulticastSink.prototype.remove = function(sink) {\n\tthis.sinks = base.remove(base.findIndex(sink, this.sinks), this.sinks);\n\treturn this.sinks.length;\n};\n\nMulticastSink.prototype.event = function(t, x) {\n\tvar s = this.sinks;\n\tif(s.length === 1) {\n\t\ts[0].event(t, x);\n\t\treturn;\n\t}\n\tfor(var i=0; i<s.length; ++i) {\n\t\ts[i].event(t, x);\n\t}\n};\n\nMulticastSink.prototype.end = function(t, x) {\n\tvar s = this.sinks;\n\tif(s.length === 1) {\n\t\ts[0].end(t, x);\n\t\treturn;\n\t}\n\tfor(var i=0; i<s.length; ++i) {\n\t\ts[i].end(t, x);\n\t}\n};\n\nMulticastSink.prototype.error = function(t, e) {\n\tvar s = this.sinks;\n\tif(s.length === 1) {\n\t\ts[0].error(t, e);\n\t\treturn;\n\t}\n\tfor (var i=0; i<s.length; ++i) {\n\t\ts[i].error(t, e);\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/MulticastSource.js\n ** module id = 17\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar unhandledRejection = require('when/lib/decorators/unhandledRejection');\nmodule.exports = unhandledRejection(require('when/lib/Promise'));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/Promise.js\n ** module id = 18\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar setTimer = require('../env').setTimer;\n\tvar format = require('../format');\n\n\treturn function unhandledRejection(Promise) {\n\n\t\tvar logError = noop;\n\t\tvar logInfo = noop;\n\t\tvar localConsole;\n\n\t\tif(typeof console !== 'undefined') {\n\t\t\t// Alias console to prevent things like uglify's drop_console option from\n\t\t\t// removing console.log/error. Unhandled rejections fall into the same\n\t\t\t// category as uncaught exceptions, and build tools shouldn't silence them.\n\t\t\tlocalConsole = console;\n\t\t\tlogError = typeof localConsole.error !== 'undefined'\n\t\t\t\t? function (e) { localConsole.error(e); }\n\t\t\t\t: function (e) { localConsole.log(e); };\n\n\t\t\tlogInfo = typeof localConsole.info !== 'undefined'\n\t\t\t\t? function (e) { localConsole.info(e); }\n\t\t\t\t: function (e) { localConsole.log(e); };\n\t\t}\n\n\t\tPromise.onPotentiallyUnhandledRejection = function(rejection) {\n\t\t\tenqueue(report, rejection);\n\t\t};\n\n\t\tPromise.onPotentiallyUnhandledRejectionHandled = function(rejection) {\n\t\t\tenqueue(unreport, rejection);\n\t\t};\n\n\t\tPromise.onFatalRejection = function(rejection) {\n\t\t\tenqueue(throwit, rejection.value);\n\t\t};\n\n\t\tvar tasks = [];\n\t\tvar reported = [];\n\t\tvar running = null;\n\n\t\tfunction report(r) {\n\t\t\tif(!r.handled) {\n\t\t\t\treported.push(r);\n\t\t\t\tlogError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));\n\t\t\t}\n\t\t}\n\n\t\tfunction unreport(r) {\n\t\t\tvar i = reported.indexOf(r);\n\t\t\tif(i >= 0) {\n\t\t\t\treported.splice(i, 1);\n\t\t\t\tlogInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));\n\t\t\t}\n\t\t}\n\n\t\tfunction enqueue(f, x) {\n\t\t\ttasks.push(f, x);\n\t\t\tif(running === null) {\n\t\t\t\trunning = setTimer(flush, 0);\n\t\t\t}\n\t\t}\n\n\t\tfunction flush() {\n\t\t\trunning = null;\n\t\t\twhile(tasks.length > 0) {\n\t\t\t\ttasks.shift()(tasks.shift());\n\t\t\t}\n\t\t}\n\n\t\treturn Promise;\n\t};\n\n\tfunction throwit(e) {\n\t\tthrow e;\n\t}\n\n\tfunction noop() {}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/~/when/lib/decorators/unhandledRejection.js\n ** module id = 19\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/\n(function(define) { 'use strict';\ndefine(function(require) {\n\t/*jshint maxcomplexity:6*/\n\n\t// Sniff \"best\" async scheduling option\n\t// Prefer process.nextTick or MutationObserver, then check for\n\t// setTimeout, and finally vertx, since its the only env that doesn't\n\t// have setTimeout\n\n\tvar MutationObs;\n\tvar capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;\n\n\t// Default env\n\tvar setTimer = function(f, ms) { return setTimeout(f, ms); };\n\tvar clearTimer = function(t) { return clearTimeout(t); };\n\tvar asap = function (f) { return capturedSetTimeout(f, 0); };\n\n\t// Detect specific env\n\tif (isNode()) { // Node\n\t\tasap = function (f) { return process.nextTick(f); };\n\n\t} else if (MutationObs = hasMutationObserver()) { // Modern browser\n\t\tasap = initMutationObserver(MutationObs);\n\n\t} else if (!capturedSetTimeout) { // vert.x\n\t\tvar vertxRequire = require;\n\t\tvar vertx = vertxRequire('vertx');\n\t\tsetTimer = function (f, ms) { return vertx.setTimer(ms, f); };\n\t\tclearTimer = vertx.cancelTimer;\n\t\tasap = vertx.runOnLoop || vertx.runOnContext;\n\t}\n\n\treturn {\n\t\tsetTimer: setTimer,\n\t\tclearTimer: clearTimer,\n\t\tasap: asap\n\t};\n\n\tfunction isNode () {\n\t\treturn typeof process !== 'undefined' &&\n\t\t\tObject.prototype.toString.call(process) === '[object process]';\n\t}\n\n\tfunction hasMutationObserver () {\n\t\treturn (typeof MutationObserver === 'function' && MutationObserver) ||\n\t\t\t(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);\n\t}\n\n\tfunction initMutationObserver(MutationObserver) {\n\t\tvar scheduled;\n\t\tvar node = document.createTextNode('');\n\t\tvar o = new MutationObserver(run);\n\t\to.observe(node, { characterData: true });\n\n\t\tfunction run() {\n\t\t\tvar f = scheduled;\n\t\t\tscheduled = void 0;\n\t\t\tf();\n\t\t}\n\n\t\tvar i = 0;\n\t\treturn function (f) {\n\t\t\tscheduled = f;\n\t\t\tnode.data = (i ^= 1);\n\t\t};\n\t}\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/~/when/lib/env.js\n ** module id = 20\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 21\n ** module chunks = 0\n **/","/* (ignored) */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** vertx (ignored)\n ** module id = 22\n ** module chunks = 0\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 23\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn {\n\t\tformatError: formatError,\n\t\tformatObject: formatObject,\n\t\ttryStringify: tryStringify\n\t};\n\n\t/**\n\t * Format an error into a string.  If e is an Error and has a stack property,\n\t * it's returned.  Otherwise, e is formatted using formatObject, with a\n\t * warning added about e not being a proper Error.\n\t * @param {*} e\n\t * @returns {String} formatted string, suitable for output to developers\n\t */\n\tfunction formatError(e) {\n\t\tvar s = typeof e === 'object' && e !== null && e.stack ? e.stack : formatObject(e);\n\t\treturn e instanceof Error ? s : s + ' (WARNING: non-Error used)';\n\t}\n\n\t/**\n\t * Format an object, detecting \"plain\" objects and running them through\n\t * JSON.stringify if possible.\n\t * @param {Object} o\n\t * @returns {string}\n\t */\n\tfunction formatObject(o) {\n\t\tvar s = String(o);\n\t\tif(s === '[object Object]' && typeof JSON !== 'undefined') {\n\t\t\ts = tryStringify(o, s);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * Try to return the result of JSON.stringify(x).  If that fails, return\n\t * defaultValue\n\t * @param {*} x\n\t * @param {*} defaultValue\n\t * @returns {String|*} JSON.stringify(x) or defaultValue\n\t */\n\tfunction tryStringify(x, defaultValue) {\n\t\ttry {\n\t\t\treturn JSON.stringify(x);\n\t\t} catch(e) {\n\t\t\treturn defaultValue;\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/~/when/lib/format.js\n ** module id = 24\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar makePromise = require('./makePromise');\n\tvar Scheduler = require('./Scheduler');\n\tvar async = require('./env').asap;\n\n\treturn makePromise({\n\t\tscheduler: new Scheduler(async)\n\t});\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/~/when/lib/Promise.js\n ** module id = 25\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar tasks = environment.scheduler;\n\t\tvar emitRejection = initEmitRejection();\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver, handler) {\n\t\t\tthis._handler = resolver === Handler ? handler : init(resolver);\n\t\t}\n\n\t\t/**\n\t\t * Run the supplied resolver\n\t\t * @param resolver\n\t\t * @returns {Pending}\n\t\t */\n\t\tfunction init(resolver) {\n\t\t\tvar handler = new Pending();\n\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\n\t\t\treturn handler;\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\thandler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {Error|*} reason rejection reason, strongly suggested\n\t\t\t *   to be an Error type\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\thandler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @deprecated\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\thandler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\t\tPromise._handler = getHandler;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn isPromise(x) ? x\n\t\t\t\t: new Promise(Handler, new Async(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new Promise(Handler, new Async(new Rejected(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new Promise(Handler, new Pending());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param {function=} onFulfilled fulfillment handler\n\t\t * @param {function=} onRejected rejection handler\n\t\t * @param {function=} onProgress @deprecated progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected, onProgress) {\n\t\t\tvar parent = this._handler;\n\t\t\tvar state = parent.join().state();\n\n\t\t\tif ((typeof onFulfilled !== 'function' && state > 0) ||\n\t\t\t\t(typeof onRejected !== 'function' && state < 0)) {\n\t\t\t\t// Short circuit: value will not change, simply share handler\n\t\t\t\treturn new this.constructor(Handler, parent);\n\t\t\t}\n\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\n\t\t\tparent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);\n\n\t\t\treturn p;\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Creates a new, pending promise of the same type as this promise\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._beget = function() {\n\t\t\treturn begetFrom(this._handler, this.constructor);\n\t\t};\n\n\t\tfunction begetFrom(parent, Promise) {\n\t\t\tvar child = new Pending(parent.receiver, parent.join().context);\n\t\t\treturn new Promise(Handler, child);\n\t\t}\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\t\tPromise._traverse = traverse;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\treturn traverseWith(snd, null, promises);\n\t\t}\n\n\t\t/**\n\t\t * Array<Promise<X>> -> Promise<Array<f(X)>>\n\t\t * @private\n\t\t * @param {function} f function to apply to each promise's value\n\t\t * @param {Array} promises array of promises\n\t\t * @returns {Promise} promise for transformed values\n\t\t */\n\t\tfunction traverse(f, promises) {\n\t\t\treturn traverseWith(tryCatch2, f, promises);\n\t\t}\n\n\t\tfunction traverseWith(tryMap, f, promises) {\n\t\t\tvar handler = typeof f === 'function' ? mapAt : settleAt;\n\n\t\t\tvar resolver = new Pending();\n\t\t\tvar pending = promises.length >>> 0;\n\t\t\tvar results = new Array(pending);\n\n\t\t\tfor (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {\n\t\t\t\tx = promises[i];\n\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttraverseAt(promises, handler, i, x, resolver);\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t}\n\n\t\t\treturn new Promise(Handler, resolver);\n\n\t\t\tfunction mapAt(i, x, resolver) {\n\t\t\t\tif(!resolver.resolved) {\n\t\t\t\t\ttraverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction settleAt(i, x, resolver) {\n\t\t\t\tresults[i] = x;\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction traverseAt(promises, handler, i, x, resolver) {\n\t\t\tif (maybeThenable(x)) {\n\t\t\t\tvar h = getHandlerMaybeThenable(x);\n\t\t\t\tvar s = h.state();\n\n\t\t\t\tif (s === 0) {\n\t\t\t\t\th.fold(handler, i, void 0, resolver);\n\t\t\t\t} else if (s > 0) {\n\t\t\t\t\thandler(i, h.value, resolver);\n\t\t\t\t} else {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandler(i, x, resolver);\n\t\t\t}\n\t\t}\n\n\t\tPromise._visitRemaining = visitRemaining;\n\t\tfunction visitRemaining(promises, start, handler) {\n\t\t\tfor(var i=start; i<promises.length; ++i) {\n\t\t\t\tmarkAsHandled(getHandler(promises[i]), handler);\n\t\t\t}\n\t\t}\n\n\t\tfunction markAsHandled(h, handler) {\n\t\t\tif(h === handler) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar s = h.state();\n\t\t\tif(s === 0) {\n\t\t\t\th.visit(h, void 0, h._unreport);\n\t\t\t} else if(s < 0) {\n\t\t\t\th._unreport();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\tif(typeof promises !== 'object' || promises === null) {\n\t\t\t\treturn reject(new TypeError('non-iterable passed to race()'));\n\t\t\t}\n\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\treturn promises.length === 0 ? never()\n\t\t\t\t : promises.length === 1 ? resolve(promises[0])\n\t\t\t\t : runRace(promises);\n\t\t}\n\n\t\tfunction runRace(promises) {\n\t\t\tvar resolver = new Pending();\n\t\t\tvar i, x, h;\n\t\t\tfor(i=0; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = getHandler(x);\n\t\t\t\tif(h.state() !== 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, resolver.resolve, resolver.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Promise(Handler, resolver);\n\t\t}\n\n\t\t// Promise internals\n\t\t// Below this, everything is @private\n\n\t\t/**\n\t\t * Get an appropriate handler for x, without checking for cycles\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x) {\n\t\t\tif(isPromise(x)) {\n\t\t\t\treturn x._handler.join();\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for thenable x.\n\t\t * NOTE: You must only call this if maybeThenable(x) == true\n\t\t * @param {object|function|Promise} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerMaybeThenable(x) {\n\t\t\treturn isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new Thenable(untrustedThen, x)\n\t\t\t\t\t: new Fulfilled(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new Rejected(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.when\n\t\t\t= Handler.prototype.become\n\t\t\t= Handler.prototype.notify // deprecated\n\t\t\t= Handler.prototype.fail\n\t\t\t= Handler.prototype._unreport\n\t\t\t= Handler.prototype._report\n\t\t\t= noop;\n\n\t\tHandler.prototype._state = 0;\n\n\t\tHandler.prototype.state = function() {\n\t\t\treturn this._state;\n\t\t};\n\n\t\t/**\n\t\t * Recursively collapse handler chain to find the handler\n\t\t * nearest to the fully resolved value.\n\t\t * @returns {object} handler nearest the fully resolved value\n\t\t */\n\t\tHandler.prototype.join = function() {\n\t\t\tvar h = this;\n\t\t\twhile(h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t}\n\t\t\treturn h;\n\t\t};\n\n\t\tHandler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {\n\t\t\tthis.when({\n\t\t\t\tresolver: to,\n\t\t\t\treceiver: receiver,\n\t\t\t\tfulfilled: fulfilled,\n\t\t\t\trejected: rejected,\n\t\t\t\tprogress: progress\n\t\t\t});\n\t\t};\n\n\t\tHandler.prototype.visit = function(receiver, fulfilled, rejected, progress) {\n\t\t\tthis.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n\t\t};\n\n\t\tHandler.prototype.fold = function(f, z, c, to) {\n\t\t\tthis.when(new Fold(f, z, c, to));\n\t\t};\n\n\t\t/**\n\t\t * Handler that invokes fail() on any handler it becomes\n\t\t * @constructor\n\t\t */\n\t\tfunction FailIfRejected() {}\n\n\t\tinherit(Handler, FailIfRejected);\n\n\t\tFailIfRejected.prototype.become = function(h) {\n\t\t\th.fail();\n\t\t};\n\n\t\tvar failIfRejected = new FailIfRejected();\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @constructor\n\t\t */\n\t\tfunction Pending(receiver, inheritedContext) {\n\t\t\tPromise.createContext(this, inheritedContext);\n\n\t\t\tthis.consumers = void 0;\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t}\n\n\t\tinherit(Handler, Pending);\n\n\t\tPending.prototype._state = 0;\n\n\t\tPending.prototype.resolve = function(x) {\n\t\t\tthis.become(getHandler(x));\n\t\t};\n\n\t\tPending.prototype.reject = function(x) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.become(new Rejected(x));\n\t\t};\n\n\t\tPending.prototype.join = function() {\n\t\t\tif (!this.resolved) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar h = this;\n\n\t\t\twhile (h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t\tif (h === this) {\n\t\t\t\t\treturn this.handler = cycle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn h;\n\t\t};\n\n\t\tPending.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.handler;\n\t\t\tthis.handler = this.handler.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; ++i) {\n\t\t\t\thandler.when(q[i]);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.become = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\tif(this.consumers !== void 0) {\n\t\t\t\ttasks.enqueue(this);\n\t\t\t}\n\n\t\t\tif(this.context !== void 0) {\n\t\t\t\thandler._report(this.context);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.when = function(continuation) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new ContinuationTask(continuation, this.handler));\n\t\t\t} else {\n\t\t\t\tif(this.consumers === void 0) {\n\t\t\t\t\tthis.consumers = [continuation];\n\t\t\t\t} else {\n\t\t\t\t\tthis.consumers.push(continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tPending.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(x, this));\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.fail = function(context) {\n\t\t\tvar c = typeof context === 'undefined' ? this.context : context;\n\t\t\tthis.resolved && this.handler.join().fail(c);\n\t\t};\n\n\t\tPending.prototype._report = function(context) {\n\t\t\tthis.resolved && this.handler.join()._report(context);\n\t\t};\n\n\t\tPending.prototype._unreport = function() {\n\t\t\tthis.resolved && this.handler.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction Async(handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tinherit(Handler, Async);\n\n\t\tAsync.prototype.when = function(continuation) {\n\t\t\ttasks.enqueue(new ContinuationTask(continuation, this));\n\t\t};\n\n\t\tAsync.prototype._report = function(context) {\n\t\t\tthis.join()._report(context);\n\t\t};\n\n\t\tAsync.prototype._unreport = function() {\n\t\t\tthis.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction Thenable(then, thenable) {\n\t\t\tPending.call(this);\n\t\t\ttasks.enqueue(new AssimilateTask(then, thenable, this));\n\t\t}\n\n\t\tinherit(Pending, Thenable);\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction Fulfilled(x) {\n\t\t\tPromise.createContext(this);\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tinherit(Handler, Fulfilled);\n\n\t\tFulfilled.prototype._state = 1;\n\n\t\tFulfilled.prototype.fold = function(f, z, c, to) {\n\t\t\trunContinuation3(f, z, this, c, to);\n\t\t};\n\n\t\tFulfilled.prototype.when = function(cont) {\n\t\t\trunContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tvar errorId = 0;\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction Rejected(x) {\n\t\t\tPromise.createContext(this);\n\n\t\t\tthis.id = ++errorId;\n\t\t\tthis.value = x;\n\t\t\tthis.handled = false;\n\t\t\tthis.reported = false;\n\n\t\t\tthis._report();\n\t\t}\n\n\t\tinherit(Handler, Rejected);\n\n\t\tRejected.prototype._state = -1;\n\n\t\tRejected.prototype.fold = function(f, z, c, to) {\n\t\t\tto.become(this);\n\t\t};\n\n\t\tRejected.prototype.when = function(cont) {\n\t\t\tif(typeof cont.rejected === 'function') {\n\t\t\t\tthis._unreport();\n\t\t\t}\n\t\t\trunContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tRejected.prototype._report = function(context) {\n\t\t\ttasks.afterQueue(new ReportTask(this, context));\n\t\t};\n\n\t\tRejected.prototype._unreport = function() {\n\t\t\tif(this.handled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handled = true;\n\t\t\ttasks.afterQueue(new UnreportTask(this));\n\t\t};\n\n\t\tRejected.prototype.fail = function(context) {\n\t\t\tthis.reported = true;\n\t\t\temitRejection('unhandledRejection', this);\n\t\t\tPromise.onFatalRejection(this, context === void 0 ? this.context : context);\n\t\t};\n\n\t\tfunction ReportTask(rejection, context) {\n\t\t\tthis.rejection = rejection;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tReportTask.prototype.run = function() {\n\t\t\tif(!this.rejection.handled && !this.rejection.reported) {\n\t\t\t\tthis.rejection.reported = true;\n\t\t\t\temitRejection('unhandledRejection', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n\t\t\t}\n\t\t};\n\n\t\tfunction UnreportTask(rejection) {\n\t\t\tthis.rejection = rejection;\n\t\t}\n\n\t\tUnreportTask.prototype.run = function() {\n\t\t\tif(this.rejection.reported) {\n\t\t\t\temitRejection('rejectionHandled', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n\t\t\t}\n\t\t};\n\n\t\t// Unhandled rejection hooks\n\t\t// By default, everything is a noop\n\n\t\tPromise.createContext\n\t\t\t= Promise.enterContext\n\t\t\t= Promise.exitContext\n\t\t\t= Promise.onPotentiallyUnhandledRejection\n\t\t\t= Promise.onPotentiallyUnhandledRejectionHandled\n\t\t\t= Promise.onFatalRejection\n\t\t\t= noop;\n\n\t\t// Errors and singletons\n\n\t\tvar foreverPendingHandler = new Handler();\n\t\tvar foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n\t\tfunction cycle() {\n\t\t\treturn new Rejected(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @constructor\n\t\t */\n\t\tfunction ContinuationTask(continuation, handler) {\n\t\t\tthis.continuation = continuation;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tContinuationTask.prototype.run = function() {\n\t\t\tthis.handler.join().when(this.continuation);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(value, handler) {\n\t\t\tthis.handler = handler;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.handler.consumers;\n\t\t\tif(q === void 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var c, i = 0; i < q.length; ++i) {\n\t\t\t\tc = q[i];\n\t\t\t\trunNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Assimilate a thenable, sending it's value to resolver\n\t\t * @param {function} then\n\t\t * @param {object|function} thenable\n\t\t * @param {object} resolver\n\t\t * @constructor\n\t\t */\n\t\tfunction AssimilateTask(then, thenable, resolver) {\n\t\t\tthis._then = then;\n\t\t\tthis.thenable = thenable;\n\t\t\tthis.resolver = resolver;\n\t\t}\n\n\t\tAssimilateTask.prototype.run = function() {\n\t\t\tvar h = this.resolver;\n\t\t\ttryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tfunction tryAssimilate(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fold a handler value with z\n\t\t * @constructor\n\t\t */\n\t\tfunction Fold(f, z, c, to) {\n\t\t\tthis.f = f; this.z = z; this.c = c; this.to = to;\n\t\t\tthis.resolver = failIfRejected;\n\t\t\tthis.receiver = this;\n\t\t}\n\n\t\tFold.prototype.fulfilled = function(x) {\n\t\t\tthis.f.call(this.c, this.z, x, this.to);\n\t\t};\n\n\t\tFold.prototype.rejected = function(x) {\n\t\t\tthis.to.reject(x);\n\t\t};\n\n\t\tFold.prototype.progress = function(x) {\n\t\t\tthis.to.notify(x);\n\t\t};\n\n\t\t// Other helpers\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} true iff x is a trusted Promise\n\t\t */\n\t\tfunction isPromise(x) {\n\t\t\treturn x instanceof Promise;\n\t\t}\n\n\t\t/**\n\t\t * Test just enough to rule out primitives, in order to take faster\n\t\t * paths in some code\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\tfunction runContinuation1(f, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject(f, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runContinuation3(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject3(f, x, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tfunction runNotify(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.notify(x);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReturn(f, x, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction tryCatch2(f, a, b) {\n\t\t\ttry {\n\t\t\t\treturn f(a, b);\n\t\t\t} catch(e) {\n\t\t\t\treturn reject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.become(getHandler(f.call(thisArg, x)));\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Same as above, but includes the extra argument parameter.\n\t\t */\n\t\tfunction tryCatchReject3(f, x, y, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tf.call(thisArg, x, y, next);\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.notify(f.call(thisArg, x));\n\t\t\t} catch(e) {\n\t\t\t\tnext.notify(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction inherit(Parent, Child) {\n\t\t\tChild.prototype = objectCreate(Parent.prototype);\n\t\t\tChild.prototype.constructor = Child;\n\t\t}\n\n\t\tfunction snd(x, y) {\n\t\t\treturn y;\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\tfunction initEmitRejection() {\n\t\t\t/*global process, self, CustomEvent*/\n\t\t\tif(typeof process !== 'undefined' && process !== null\n\t\t\t\t&& typeof process.emit === 'function') {\n\t\t\t\t// Returning falsy here means to call the default\n\t\t\t\t// onPotentiallyUnhandledRejection API.  This is safe even in\n\t\t\t\t// browserify since process.emit always returns falsy in browserify:\n\t\t\t\t// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46\n\t\t\t\treturn function(type, rejection) {\n\t\t\t\t\treturn type === 'unhandledRejection'\n\t\t\t\t\t\t? process.emit(type, rejection.value, rejection)\n\t\t\t\t\t\t: process.emit(type, rejection);\n\t\t\t\t};\n\t\t\t} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {\n\t\t\t\treturn (function(noop, self, CustomEvent) {\n\t\t\t\t\tvar hasCustomEvent = false;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar ev = new CustomEvent('unhandledRejection');\n\t\t\t\t\t\thasCustomEvent = ev instanceof CustomEvent;\n\t\t\t\t\t} catch (e) {}\n\n\t\t\t\t\treturn !hasCustomEvent ? noop : function(type, rejection) {\n\t\t\t\t\t\tvar ev = new CustomEvent(type, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\treason: rejection.value,\n\t\t\t\t\t\t\t\tkey: rejection\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbubbles: false,\n\t\t\t\t\t\t\tcancelable: true\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !self.dispatchEvent(ev);\n\t\t\t\t\t};\n\t\t\t\t}(noop, self, CustomEvent));\n\t\t\t}\n\n\t\t\treturn noop;\n\t\t}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/~/when/lib/makePromise.js\n ** module id = 26\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for next-tick conflation.\n\n\t/**\n\t * Async task scheduler\n\t * @param {function} async function to schedule a single async function\n\t * @constructor\n\t */\n\tfunction Scheduler(async) {\n\t\tthis._async = async;\n\t\tthis._running = false;\n\n\t\tthis._queue = this;\n\t\tthis._queueLen = 0;\n\t\tthis._afterQueue = {};\n\t\tthis._afterQueueLen = 0;\n\n\t\tvar self = this;\n\t\tthis.drain = function() {\n\t\t\tself._drain();\n\t\t};\n\t}\n\n\t/**\n\t * Enqueue a task\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.enqueue = function(task) {\n\t\tthis._queue[this._queueLen++] = task;\n\t\tthis.run();\n\t};\n\n\t/**\n\t * Enqueue a task to run after the main task queue\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.afterQueue = function(task) {\n\t\tthis._afterQueue[this._afterQueueLen++] = task;\n\t\tthis.run();\n\t};\n\n\tScheduler.prototype.run = function() {\n\t\tif (!this._running) {\n\t\t\tthis._running = true;\n\t\t\tthis._async(this.drain);\n\t\t}\n\t};\n\n\t/**\n\t * Drain the handler queue entirely, and then the after queue\n\t */\n\tScheduler.prototype._drain = function() {\n\t\tvar i = 0;\n\t\tfor (; i < this._queueLen; ++i) {\n\t\t\tthis._queue[i].run();\n\t\t\tthis._queue[i] = void 0;\n\t\t}\n\n\t\tthis._queueLen = 0;\n\t\tthis._running = false;\n\n\t\tfor (i = 0; i < this._afterQueueLen; ++i) {\n\t\t\tthis._afterQueue[i].run();\n\t\t\tthis._afterQueue[i] = void 0;\n\t\t}\n\n\t\tthis._afterQueueLen = 0;\n\t};\n\n\treturn Scheduler;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/~/when/lib/Scheduler.js\n ** module id = 27\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar MulticastSource = require('./MulticastSource');\nvar DeferredSink = require('../sink/DeferredSink');\n\nexports.create = create;\n\nfunction create(run) {\n\treturn new Stream(new MulticastSource(new SubscriberSource(run)));\n}\n\nfunction SubscriberSource(subscribe) {\n\tthis._subscribe = subscribe;\n}\n\nSubscriberSource.prototype.run = function(sink, scheduler) {\n\treturn new Subscription(new DeferredSink(sink), scheduler, this._subscribe);\n};\n\nfunction Subscription(sink, scheduler, subscribe) {\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n\tthis.active = true;\n\n\tvar s = this;\n\n\ttry {\n\t\tthis._unsubscribe = subscribe(add, end, error);\n\t} catch(e) {\n\t\terror(e);\n\t}\n\n\tfunction add(x) {\n\t\ts._add(x);\n\t}\n\tfunction end(x) {\n\t\ts._end(x);\n\t}\n\tfunction error(e) {\n\t\ts._error(e);\n\t}\n}\n\nSubscription.prototype._add = function(x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\ttryEvent(this.scheduler.now(), x, this.sink);\n};\n\nSubscription.prototype._end = function(x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\tthis.active = false;\n\ttryEnd(this.scheduler.now(), x, this.sink);\n};\n\nSubscription.prototype._error = function(x) {\n\tthis.active = false;\n\tthis.sink.error(this.scheduler.now(), x);\n};\n\nSubscription.prototype.dispose = function() {\n\tthis.active = false;\n\tif(typeof this._unsubscribe === 'function') {\n\t\treturn this._unsubscribe();\n\t}\n};\n\nfunction tryEvent(t, x, sink) {\n\ttry {\n\t\tsink.event(t, x);\n\t} catch(e) {\n\t\tsink.error(t, e);\n\t}\n}\n\nfunction tryEnd(t, x, sink) {\n\ttry {\n\t\tsink.end(t, x);\n\t} catch(e) {\n\t\tsink.error(t, e);\n\t}\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/create.js\n ** module id = 28\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar defer = require('../defer');\n\nmodule.exports = DeferredSink;\n\nfunction DeferredSink(sink) {\n\tthis.sink = sink;\n\tthis.events = [];\n\tthis.length = 0;\n\tthis.active = true;\n}\n\nDeferredSink.prototype.event = function(t, x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\n\tif(this.length === 0) {\n\t\tdefer(new PropagateAllTask(this));\n\t}\n\n\tthis.events[this.length++] = { time: t, value: x };\n};\n\nDeferredSink.prototype.error = function(t, e) {\n\tthis.active = false;\n\tdefer(new ErrorTask(t, e, this.sink));\n};\n\nDeferredSink.prototype.end = function(t, x) {\n\tthis.active = false;\n\tdefer(new EndTask(t, x, this.sink));\n};\n\nfunction PropagateAllTask(deferred) {\n\tthis.deferred = deferred;\n}\n\nPropagateAllTask.prototype.run = function() {\n\tvar p = this.deferred;\n\tvar events = p.events;\n\tvar sink = p.sink;\n\tvar event;\n\n\tfor(var i = 0, l = p.length; i<l; ++i) {\n\t\tevent = events[i];\n\t\tsink.event(event.time, event.value);\n\t\tevents[i] = void 0;\n\t}\n\n\tp.length = 0;\n};\n\nPropagateAllTask.prototype.error = function(e) {\n\tthis.deferred.error(0, e);\n};\n\nfunction EndTask(t, x, sink) {\n\tthis.time = t;\n\tthis.value = x;\n\tthis.sink = sink;\n}\n\nEndTask.prototype.run = function() {\n\tthis.sink.end(this.time, this.value);\n};\n\nEndTask.prototype.error = function(e) {\n\tthis.sink.error(this.time, e);\n};\n\nfunction ErrorTask(t, e, sink) {\n\tthis.time = t;\n\tthis.value = e;\n\tthis.sink = sink;\n}\n\nErrorTask.prototype.run = function() {\n\tthis.sink.error(this.time, this.value);\n};\n\nErrorTask.prototype.error = function(e) {\n\tthrow e;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/sink/DeferredSink.js\n ** module id = 29\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Promise = require('./Promise');\n\nmodule.exports = defer;\n\nfunction defer(task) {\n\treturn Promise.resolve(task).then(runTask);\n}\n\nfunction runTask(task) {\n\ttry {\n\t\treturn task.run();\n\t} catch(e) {\n\t\treturn task.error(e);\n\t}\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/defer.js\n ** module id = 30\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar MulticastSource = require('./MulticastSource');\nvar DeferredSink = require('../sink/DeferredSink');\n\nexports.fromEvent = fromEvent;\n\n/**\n * Create a stream from an EventTarget, such as a DOM Node, or EventEmitter.\n * @param {String} event event type name, e.g. 'click'\n * @param {EventTarget|EventEmitter} source EventTarget or EventEmitter\n * @returns {Stream} stream containing all events of the specified type\n * from the source.\n */\nfunction fromEvent(event, source) {\n\tvar s;\n\tif(typeof source.addEventListener === 'function' && typeof source.removeEventListener === 'function') {\n\t\ts = new MulticastSource(new EventTargetSource(event, source));\n\t} else if(typeof source.addListener === 'function' && typeof source.removeListener === 'function') {\n\t\ts = new EventEmitterSource(event, source);\n\t} else {\n\t\tthrow new Error('source must support addEventListener/removeEventListener or addListener/removeListener');\n\t}\n\n\treturn new Stream(s);\n}\n\nfunction EventTargetSource(event, source) {\n\tthis.event = event;\n\tthis.source = source;\n}\n\nEventTargetSource.prototype.run = function(sink, scheduler) {\n\treturn new EventAdapter(initEventTarget, this.event, this.source, sink, scheduler);\n};\n\nfunction initEventTarget(addEvent, event, source) {\n\tsource.addEventListener(event, addEvent, false);\n\treturn function(event, target) {\n\t\ttarget.removeEventListener(event, addEvent, false);\n\t};\n}\n\nfunction EventEmitterSource(event, source) {\n\tthis.event = event;\n\tthis.source = source;\n}\n\nEventEmitterSource.prototype.run = function(sink, scheduler) {\n\t// NOTE: Because EventEmitter allows events in the same call stack as\n\t// a listener is added, use a DeferredSink to buffer events\n\t// until the stack clears, then propagate.  This maintains most.js's\n\t// invariant that no event will be delivered in the same call stack\n\t// as an observer begins observing.\n\treturn new EventAdapter(initEventEmitter, this.event, this.source, new DeferredSink(sink), scheduler);\n};\n\nfunction initEventEmitter(addEvent, event, source) {\n\t// EventEmitter supports varargs (eg: emitter.emit('event', a, b, c, ...)) so\n\t// have to support it here by turning into an array\n\tfunction addEventVariadic(a) {\n\t\tvar l = arguments.length;\n\t\tif(l > 1) {\n\t\t\tvar arr = new Array(l);\n\t\t\tfor(var i=0; i<l; ++i) {\n\t\t\t\tarr[i] = arguments[i];\n\t\t\t}\n\t\t\taddEvent(arr);\n\t\t} else {\n\t\t\taddEvent(a);\n\t\t}\n\t}\n\n\tsource.addListener(event, addEventVariadic);\n\n\treturn function(event, target) {\n\t\ttarget.removeListener(event, addEventVariadic);\n\t};\n}\n\nfunction EventAdapter(init, event, source, sink, scheduler) {\n\tthis.event = event;\n\tthis.source = source;\n\n\tfunction addEvent(ev) {\n\t\ttryEvent(scheduler.now(), ev, sink);\n\t}\n\n\tthis._dispose = init(addEvent, event, source);\n}\n\nEventAdapter.prototype.dispose = function() {\n\treturn this._dispose(this.event, this.source);\n};\n\nfunction tryEvent (t, x, sink) {\n\ttry {\n\t\tsink.event(t, x);\n\t} catch(e) {\n\t\tsink.error(t, e);\n\t}\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/fromEvent.js\n ** module id = 31\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar combine = require('./combine').combineArray;\n\nvar paramsRx = /\\(([^)]*)/;\nvar liftedSuffix = '_most$Stream$lifted';\n\nexports.lift = lift;\n\n/**\n * @deprecated\n * Lift a function to operate on streams.  For example:\n * lift(function(x:number, y:number):number) -> function(xs:Stream, ys:Stream):Stream\n * @param {function} f function to be lifted\n * @returns {function} function with the same arity as f that accepts\n *  streams as arguments and returns a stream\n */\nfunction lift (f) {\n\t/*jshint evil:true*/\n\tvar m = paramsRx.exec(f.toString());\n\tvar body = 'return function ' + f.name + liftedSuffix + ' (' + m[1] + ') {\\n' +\n\t\t\t'  return combine(f, arguments);\\n' +\n\t\t\t'};';\n\n\treturn (new Function('combine', 'f', body)(combine, f));\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/lift.js\n ** module id = 32\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar transform = require('./transform');\nvar core = require('../source/core');\nvar Pipe = require('../sink/Pipe');\nvar IndexSink = require('../sink/IndexSink');\nvar CompoundDisposable = require('../disposable/CompoundDisposable');\nvar base = require('../base');\nvar invoke = require('../invoke');\n\nvar hasValue = IndexSink.hasValue;\nvar getValue = IndexSink.getValue;\n\nvar map = base.map;\nvar tail = base.tail;\n\nexports.combineArray = combineArray;\nexports.combine = combine;\n\n/**\n * Combine latest events from all input streams\n * @param {function(...events):*} f function to combine most recent events\n * @returns {Stream} stream containing the result of applying f to the most recent\n *  event of each input stream, whenever a new event arrives on any stream.\n */\nfunction combine(f /*, ...streams */) {\n\treturn new Stream(new Combine(f, map(getSource, tail(arguments))));\n}\n\n/**\n * Combine latest events from all input streams\n * @param {function(...events):*} f function to combine most recent events\n * @param {[Stream]} streams most recent events\n * @returns {Stream} stream containing the result of applying f to the most recent\n *  event of each input stream, whenever a new event arrives on any stream.\n */\nfunction combineArray(f, streams) {\n\treturn streams.length === 0 ? core.empty()\n\t\t : streams.length === 1 ? transform.map(f, streams[0])\n\t\t : new Stream(new Combine(f, map(getSource, streams)));\n}\n\nfunction getSource(stream) {\n\treturn stream.source;\n}\n\nfunction Combine(f, sources) {\n\tthis.f = f;\n\tthis.sources = sources;\n}\n\nCombine.prototype.run = function(sink, scheduler) {\n\tvar l = this.sources.length;\n\tvar disposables = new Array(l);\n\tvar sinks = new Array(l);\n\n\tvar combineSink = new CombineSink(this.f, sinks, sink);\n\n\tfor(var indexSink, i=0; i<l; ++i) {\n\t\tindexSink = sinks[i] = new IndexSink(i, combineSink);\n\t\tdisposables[i] = this.sources[i].run(indexSink, scheduler);\n\t}\n\n\treturn new CompoundDisposable(disposables);\n};\n\nfunction CombineSink(f, sinks, sink) {\n\tthis.f = f;\n\tthis.sinks = sinks;\n\tthis.sink = sink;\n\tthis.ready = false;\n\tthis.activeCount = sinks.length;\n}\n\nCombineSink.prototype.event = function(t /*, indexSink */) {\n\tif(!this.ready) {\n\t\tthis.ready = this.sinks.every(hasValue);\n\t}\n\n\tif(this.ready) {\n\t\t// TODO: Maybe cache values in their own array once this.ready\n\t\tthis.sink.event(t, invoke(this.f, map(getValue, this.sinks)));\n\t}\n};\n\nCombineSink.prototype.end = function(t, indexedValue) {\n\tif(--this.activeCount === 0) {\n\t\tthis.sink.end(t, indexedValue.value);\n\t}\n};\n\nCombineSink.prototype.error = Pipe.prototype.error;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/combine.js\n ** module id = 33\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Map = require('../fusion/Map');\n\nexports.map = map;\nexports.constant = constant;\nexports.tap = tap;\n\n/**\n * Transform each value in the stream by applying f to each\n * @param {function(*):*} f mapping function\n * @param {Stream} stream stream to map\n * @returns {Stream} stream containing items transformed by f\n */\nfunction map(f, stream) {\n\treturn new Stream(Map.create(f, stream.source));\n}\n\n/**\n * Replace each value in the stream with x\n * @param {*} x\n * @param {Stream} stream\n * @returns {Stream} stream containing items replaced with x\n */\nfunction constant(x, stream) {\n\treturn map(function() {\n\t\treturn x;\n\t}, stream);\n}\n\n/**\n * Perform a side effect for each item in the stream\n * @param {function(x:*):*} f side effect to execute for each item. The\n *  return value will be discarded.\n * @param {Stream} stream stream to tap\n * @returns {Stream} new stream containing the same items as this stream\n */\nfunction tap(f, stream) {\n\treturn map(function(x) {\n\t\tf(x);\n\t\treturn x;\n\t}, stream);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/transform.js\n ** module id = 34\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Pipe = require('../sink/Pipe');\nvar Filter = require('./Filter');\nvar FilterMap = require('./FilterMap');\nvar base = require('../base');\n\nmodule.exports = Map;\n\nfunction Map(f, source) {\n\tthis.f = f;\n\tthis.source = source;\n}\n\n/**\n * Create a mapped source, fusing adjacent map.map, filter.map,\n * and filter.map.map if possible\n * @param {function(*):*} f mapping function\n * @param {{run:function}} source source to map\n * @returns {Map|FilterMap} mapped source, possibly fused\n */\nMap.create = function createMap(f, source) {\n\tif(source instanceof Map) {\n\t\treturn new Map(base.compose(f, source.f), source.source);\n\t}\n\n\tif(source instanceof Filter) {\n\t\treturn new FilterMap(source.p, f, source.source);\n\t}\n\n\tif(source instanceof FilterMap) {\n\t\treturn new FilterMap(source.p, base.compose(f, source.f), source.source);\n\t}\n\n\treturn new Map(f, source);\n};\n\nMap.prototype.run = function(sink, scheduler) {\n\treturn this.source.run(new MapSink(this.f, sink), scheduler);\n};\n\nfunction MapSink(f, sink) {\n\tthis.f = f;\n\tthis.sink = sink;\n}\n\nMapSink.prototype.end   = Pipe.prototype.end;\nMapSink.prototype.error = Pipe.prototype.error;\n\nMapSink.prototype.event = function(t, x) {\n\tvar f = this.f;\n\tthis.sink.event(t, f(x));\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/fusion/Map.js\n ** module id = 35\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nmodule.exports = Pipe;\n\n/**\n * A sink mixin that simply forwards event, end, and error to\n * another sink.\n * @param sink\n * @constructor\n */\nfunction Pipe(sink) {\n\tthis.sink = sink;\n}\n\nPipe.prototype.event = function(t, x) {\n\treturn this.sink.event(t, x);\n};\n\nPipe.prototype.end = function(t, x) {\n\treturn this.sink.end(t, x);\n};\n\nPipe.prototype.error = function(t, e) {\n\treturn this.sink.error(t, e);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/sink/Pipe.js\n ** module id = 36\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Pipe = require('../sink/Pipe');\n\nmodule.exports = Filter;\n\nfunction Filter(p, source) {\n\tthis.p = p;\n\tthis.source = source;\n}\n\n/**\n * Create a filtered source, fusing adjacent filter.filter if possible\n * @param {function(x:*):boolean} p filtering predicate\n * @param {{run:function}} source source to filter\n * @returns {Filter} filtered source\n */\nFilter.create = function createFilter(p, source) {\n\tif (source instanceof Filter) {\n\t\treturn new Filter(and(source.p, p), source.source);\n\t}\n\n\treturn new Filter(p, source);\n};\n\nFilter.prototype.run = function(sink, scheduler) {\n\treturn this.source.run(new FilterSink(this.p, sink), scheduler);\n};\n\nfunction FilterSink(p, sink) {\n\tthis.p = p;\n\tthis.sink = sink;\n}\n\nFilterSink.prototype.end   = Pipe.prototype.end;\nFilterSink.prototype.error = Pipe.prototype.error;\n\nFilterSink.prototype.event = function(t, x) {\n\tvar p = this.p;\n\tp(x) && this.sink.event(t, x);\n};\n\nfunction and(p, q) {\n\treturn function(x) {\n\t\treturn p(x) && q(x);\n\t};\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/fusion/Filter.js\n ** module id = 37\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Pipe = require('../sink/Pipe');\n\nmodule.exports = FilterMap;\n\nfunction FilterMap(p, f, source) {\n\tthis.p = p;\n\tthis.f = f;\n\tthis.source = source;\n}\n\nFilterMap.prototype.run = function(sink, scheduler) {\n\treturn this.source.run(new FilterMapSink(this.p, this.f, sink), scheduler);\n};\n\nfunction FilterMapSink(p, f, sink) {\n\tthis.p = p;\n\tthis.f = f;\n\tthis.sink = sink;\n}\n\nFilterMapSink.prototype.event = function(t, x) {\n\tvar f = this.f;\n\tvar p = this.p;\n\tp(x) && this.sink.event(t, f(x));\n};\n\nFilterMapSink.prototype.end = Pipe.prototype.end;\nFilterMapSink.prototype.error = Pipe.prototype.error;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/fusion/FilterMap.js\n ** module id = 38\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Sink = require('./Pipe');\n\nmodule.exports = IndexSink;\n\nIndexSink.hasValue = hasValue;\nIndexSink.getValue = getValue;\n\nfunction hasValue(indexSink) {\n\treturn indexSink.hasValue;\n}\n\nfunction getValue(indexSink) {\n\treturn indexSink.value;\n}\n\nfunction IndexSink(i, sink) {\n\tthis.index = i;\n\tthis.sink = sink;\n\tthis.active = true;\n\tthis.hasValue = false;\n\tthis.value = void 0;\n}\n\nIndexSink.prototype.event = function(t, x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\tthis.value = x;\n\tthis.hasValue = true;\n\tthis.sink.event(t, this);\n};\n\nIndexSink.prototype.end = function(t, x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\tthis.active = false;\n\tthis.sink.end(t, { index: this.index, value: x });\n};\n\nIndexSink.prototype.error = Sink.prototype.error;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/sink/IndexSink.js\n ** module id = 39\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar all = require('../Promise').all;\nvar map = require('../base').map;\n\nmodule.exports = CompoundDisposable;\n\nfunction CompoundDisposable(disposables) {\n\tthis.disposed = false;\n\tthis.disposables = disposables;\n}\n\nCompoundDisposable.prototype.dispose = function() {\n\tif(this.disposed) {\n\t\treturn;\n\t}\n\tthis.disposed = true;\n\treturn all(map(dispose, this.disposables));\n};\n\nfunction dispose(disposable) {\n\treturn disposable.dispose();\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/disposable/CompoundDisposable.js\n ** module id = 40\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nmodule.exports = invoke;\n\nfunction invoke(f, args) {\n\t/*jshint maxcomplexity:7*/\n\tswitch(args.length) {\n\t\tcase 0: return f();\n\t\tcase 1: return f(args[0]);\n\t\tcase 2: return f(args[0], args[1]);\n\t\tcase 3: return f(args[0], args[1], args[2]);\n\t\tcase 4: return f(args[0], args[1], args[2], args[3]);\n\t\tcase 5: return f(args[0], args[1], args[2], args[3], args[4]);\n\t\tdefault:\n\t\t\treturn f.apply(void 0, args);\n\t}\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/invoke.js\n ** module id = 41\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar runSource = require('../runSource');\nvar noop = require('../base').noop;\n\nexports.observe = observe;\nexports.drain = drain;\n\n/**\n * Observe all the event values in the stream in time order. The\n * provided function `f` will be called for each event value\n * @param {function(x:T):*} f function to call with each event value\n * @param {Stream<T>} stream stream to observe\n * @return {Promise} promise that fulfills after the stream ends without\n *  an error, or rejects if the stream ends with an error.\n */\nfunction observe(f, stream) {\n\treturn runSource.withDefaultScheduler(f, stream.source);\n}\n\n/**\n * \"Run\" a stream by\n * @param stream\n * @return {*}\n */\nfunction drain(stream) {\n\treturn runSource.withDefaultScheduler(noop, stream.source);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/observe.js\n ** module id = 42\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Promise = require('./Promise');\nvar Observer = require('./sink/Observer');\nvar SettableDisposable = require('./disposable/SettableDisposable');\nvar defaultScheduler = require('./scheduler/defaultScheduler');\n\nexports.withDefaultScheduler = withDefaultScheduler;\nexports.withScheduler = withScheduler;\n\nfunction withDefaultScheduler(f, source) {\n\treturn withScheduler(f, source, defaultScheduler);\n}\n\nfunction withScheduler(f, source, scheduler) {\n\treturn new Promise(function (resolve, reject) {\n\t\tvar disposable = new SettableDisposable();\n\t\tvar observer = new Observer(f, resolve, reject, disposable);\n\n\t\tdisposable.setDisposable(source.run(observer, scheduler));\n\t});\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/runSource.js\n ** module id = 43\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Promise = require('../Promise');\n\nmodule.exports = Observer;\n\n/**\n * Sink that accepts functions to apply to each event, and to end, and error\n * signals.\n * @constructor\n */\nfunction Observer(event, end, error, disposable) {\n\tthis._event = event;\n\tthis._end = end;\n\tthis._error = error;\n\tthis._disposable = disposable;\n\tthis.active = true;\n}\n\nObserver.prototype.event = function(t, x) {\n\tif (!this.active) {\n\t\treturn;\n\t}\n\tthis._event(x);\n};\n\nObserver.prototype.end = function(t, x) {\n\tif (!this.active) {\n\t\treturn;\n\t}\n\tthis.active = false;\n\tdisposeThen(this._end, this._error, this._disposable, x);\n};\n\nObserver.prototype.error = function(t, e) {\n\tthis.active = false;\n\tdisposeThen(this._error, this._error, this._disposable, e);\n};\n\nfunction disposeThen(end, error, disposable, x) {\n\tPromise.resolve(disposable.dispose()).then(function () {\n\t\tend(x);\n\t}, error);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/sink/Observer.js\n ** module id = 44\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Promise = require('../Promise');\n\nmodule.exports = SettableDisposable;\n\nfunction SettableDisposable() {\n\tthis.disposable = void 0;\n\tthis.disposed = false;\n\tthis._resolve = void 0;\n\n\tvar self = this;\n\tthis.result = new Promise(function(resolve) {\n\t\tself._resolve = resolve;\n\t});\n}\n\nSettableDisposable.prototype.setDisposable = function(disposable) {\n\tif(this.disposable !== void 0) {\n\t\tthrow new Error('setDisposable called more than once');\n\t}\n\n\tthis.disposable = disposable;\n\n\tif(this.disposed) {\n\t\tthis._resolve(disposable.dispose());\n\t}\n};\n\nSettableDisposable.prototype.dispose = function() {\n\tif(this.disposed) {\n\t\treturn this.result;\n\t}\n\n\tthis.disposed = true;\n\n\tif(this.disposable === void 0) {\n\t\treturn this.result;\n\t}\n\n\tthis.result = this.disposable.dispose();\n\treturn this.result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/disposable/SettableDisposable.js\n ** module id = 45\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/*global setTimeout, clearTimeout*/\nvar Scheduler = require('./Scheduler');\nvar defer = require('../defer');\n\n// Default timer functions\nvar defaultSetTimer, defaultClearTimer;\n\nfunction Task(f) {\n\tthis.f = f;\n\tthis.active = true;\n}\n\nTask.prototype.run = function() {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\tvar f = this.f;\n\treturn f();\n};\n\nTask.prototype.error = function(e) {\n\tthrow e;\n};\n\nTask.prototype.cancel = function() {\n\tthis.active = false;\n};\n\nfunction runAsTask(f) {\n\tvar task = new Task(f);\n\tdefer(task);\n\treturn task;\n}\n\nif(typeof process === 'object' && typeof process.nextTick === 'function') {\n\tdefaultSetTimer = function(f, ms) {\n\t\treturn ms <= 0 ? runAsTask(f) : setTimeout(f, ms);\n\t};\n\n\tdefaultClearTimer = function(t) {\n\t\treturn t instanceof Task ? t.cancel() : clearTimeout(t);\n\t};\n}\nelse {\n\tdefaultSetTimer = function(f, ms) {\n\t\treturn setTimeout(f, ms);\n\t};\n\n\tdefaultClearTimer = function(t) {\n\t\treturn clearTimeout(t);\n\t};\n}\n\nmodule.exports = new Scheduler(defaultSetTimer, defaultClearTimer, Date.now);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/scheduler/defaultScheduler.js\n ** module id = 46\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar base = require('./../base');\n\nmodule.exports = Scheduler;\n\nfunction ScheduledTask(delay, period, task, scheduler) {\n\tthis.time = delay;\n\tthis.period = period;\n\tthis.task = task;\n\tthis.scheduler = scheduler;\n\tthis.active = true;\n}\n\nScheduledTask.prototype.run = function() {\n\treturn this.task.run(this.time);\n};\n\nScheduledTask.prototype.error = function(e) {\n\treturn this.task.error(this.time, e);\n};\n\nScheduledTask.prototype.cancel = function() {\n\tthis.scheduler.cancel(this);\n\treturn this.task.dispose();\n};\n\nfunction runTask(task) {\n\ttry {\n\t\treturn task.run();\n\t} catch(e) {\n\t\treturn task.error(e);\n\t}\n}\n\nfunction Scheduler(setTimer, clearTimer, now) {\n\tthis.now = now;\n\tthis._setTimer = setTimer;\n\tthis._clearTimer = clearTimer;\n\n\tthis._timer = null;\n\tthis._nextArrival = 0;\n\tthis._tasks = [];\n\n\tvar self = this;\n\tthis._runReadyTasksBound = function() {\n\t\tself._runReadyTasks(self.now());\n\t};\n}\n\nScheduler.prototype.asap = function(task) {\n\treturn this.schedule(0, -1, task);\n};\n\nScheduler.prototype.delay = function(delay, task) {\n\treturn this.schedule(delay, -1, task);\n};\n\nScheduler.prototype.periodic = function(period, task) {\n\treturn this.schedule(0, period, task);\n};\n\nScheduler.prototype.schedule = function(delay, period, task) {\n\tvar now = this.now();\n    var st = new ScheduledTask(now + Math.max(0, delay), period, task, this);\n\n\tinsertByTime(st, this._tasks);\n\tthis._scheduleNextRun(now);\n\treturn st;\n};\n\nScheduler.prototype.cancel = function(task) {\n\ttask.active = false;\n\tvar i = binarySearch(task.time, this._tasks);\n\n\tif(i >= 0 && i < this._tasks.length) {\n\t\tvar at = base.findIndex(task, this._tasks[i].events);\n        this._tasks[i].events.splice(at, 1);\n\t\tthis._reschedule();\n\t}\n};\n\nScheduler.prototype.cancelAll = function(f) {\n\tthis._tasks = base.removeAll(f, this._tasks);\n\tthis._reschedule();\n};\n\nScheduler.prototype._reschedule = function() {\n\tif(this._tasks.length === 0) {\n\t\tthis._unschedule();\n\t} else {\n\t\tthis._scheduleNextRun(this.now());\n\t}\n};\n\nScheduler.prototype._unschedule = function() {\n\tthis._clearTimer(this._timer);\n\tthis._timer = null;\n};\n\nScheduler.prototype._scheduleNextRun = function(now) {\n\tif(this._tasks.length === 0) {\n\t\treturn;\n\t}\n\n\tvar nextArrival = this._tasks[0].time;\n\n\tif(this._timer === null) {\n\t\tthis._scheduleNextArrival(nextArrival, now);\n\t} else if(nextArrival < this._nextArrival) {\n\t\tthis._unschedule();\n\t\tthis._scheduleNextArrival(nextArrival, now);\n\t}\n};\n\nScheduler.prototype._scheduleNextArrival = function(nextArrival, now) {\n\tthis._nextArrival = nextArrival;\n\tvar delay = Math.max(0, nextArrival - now);\n\tthis._timer = this._setTimer(this._runReadyTasksBound, delay);\n};\n\n\nScheduler.prototype._runReadyTasks = function(now) {\n\tthis._timer = null;\n\n\tthis._findAndRunTasks(now);\n\n\tthis._scheduleNextRun(this.now());\n};\n\nScheduler.prototype._findAndRunTasks = function(now) {\n\tvar tasks = this._tasks;\n\tvar l = tasks.length;\n\tvar i = 0;\n\n\twhile(i < l && tasks[i].time <= now) {\n\t\t++i;\n\t}\n\n\tthis._tasks = tasks.slice(i);\n\n\t// Run all ready tasks\n\tfor (var j = 0; j < i; ++j) {\n\t\trunTasks(tasks[j], this._tasks);\n\t}\n};\n\nfunction runTasks(timeslot, tasks) {\n\tvar events = timeslot.events;\n\tfor(var i=0; i<events.length; ++i) {\n\t\tvar task = events[i];\n\n\t\tif(task.active) {\n\t\t\trunTask(task);\n\n\t\t\t// Reschedule periodic repeating tasks\n\t\t\t// Check active again, since a task may have canceled itself\n\t\t\tif(task.period >= 0) {\n\t\t\t\ttask.time = task.time + task.period;\n\t\t\t\tinsertByTime(task, tasks);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction insertByTime(task, timeslots) {\n\tvar l = timeslots.length;\n\n\tif(l === 0) {\n\t\ttimeslots.push(newTimeslot(task.time, [task]));\n\t\treturn;\n\t}\n\n\tvar i = binarySearch(task.time, timeslots);\n\n\tif(i >= l) {\n\t\ttimeslots.push(newTimeslot(task.time, [task]));\n\t} else if(task.time === timeslots[i].time) {\n\t\ttimeslots[i].events.push(task);\n\t} else {\n\t\ttimeslots.splice(i, 0, newTimeslot(task.time, [task]));\n\t}\n}\n\nfunction binarySearch(t, sortedArray) {\n\tvar lo = 0;\n\tvar hi = sortedArray.length;\n\tvar mid, y;\n\n\twhile (lo < hi) {\n\t\tmid = Math.floor((lo + hi) / 2);\n\t\ty = sortedArray[mid];\n\n\t\tif (t === y.time) {\n\t\t\treturn mid;\n\t\t} else if (t < y.time) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid + 1;\n\t\t}\n\t}\n\treturn hi;\n}\n\nfunction newTimeslot(t, events) {\n\treturn { time: t, events: events };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/scheduler/Scheduler.js\n ** module id = 47\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Pipe = require('../sink/Pipe');\n\nexports.loop = loop;\n\n/**\n * Generalized feedback loop. Call a stepper function for each event. The stepper\n * will be called with 2 params: the current seed and the an event value.  It must\n * return a new { seed, value } pair. The `seed` will be fed back into the next\n * invocation of stepper, and the `value` will be propagated as the event value.\n * @param {function(seed:*, value:*):{seed:*, value:*}} stepper loop step function\n * @param {*} seed initial seed value passed to first stepper call\n * @param {Stream} stream event stream\n * @returns {Stream} new stream whose values are the `value` field of the objects\n * returned by the stepper\n */\nfunction loop(stepper, seed, stream) {\n\treturn new Stream(new Loop(stepper, seed, stream.source));\n}\n\nfunction Loop(stepper, seed, source) {\n\tthis.step = stepper;\n\tthis.seed = seed;\n\tthis.source = source;\n}\n\nLoop.prototype.run = function(sink, scheduler) {\n\treturn this.source.run(new LoopSink(this.step, this.seed, sink), scheduler);\n};\n\nfunction LoopSink(stepper, seed, sink) {\n\tthis.step = stepper;\n\tthis.seed = seed;\n\tthis.sink = sink;\n}\n\nLoopSink.prototype.error = Pipe.prototype.error;\n\nLoopSink.prototype.event = function(t, x) {\n\tvar result = this.step(this.seed, x);\n\tthis.seed = result.seed;\n\tthis.sink.event(t, result.value);\n};\n\nLoopSink.prototype.end = function(t) {\n\tthis.sink.end(t, this.seed);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/loop.js\n ** module id = 48\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Pipe = require('../sink/Pipe');\nvar runSource = require('../runSource');\nvar noop = require('../base').noop;\n\nexports.scan = scan;\nexports.reduce = reduce;\n\n/**\n * Create a stream containing successive reduce results of applying f to\n * the previous reduce result and the current stream item.\n * @param {function(result:*, x:*):*} f reducer function\n * @param {*} initial initial value\n * @param {Stream} stream stream to scan\n * @returns {Stream} new stream containing successive reduce results\n */\nfunction scan(f, initial, stream) {\n\treturn new Stream(new Scan(f, initial, stream.source));\n}\n\nfunction Scan(f, z, source) {\n\tthis.f = f;\n\tthis.value = z;\n\tthis.source = source;\n}\n\nScan.prototype.run = function(sink, scheduler) {\n\treturn this.source.run(new ScanSink(this.f, this.value, sink), scheduler);\n};\n\nfunction ScanSink(f, z, sink) {\n\tthis.f = f;\n\tthis.value = z;\n\tthis.sink = sink;\n\tthis.init = true;\n}\n\nScanSink.prototype.event = function(t, x) {\n\tif(this.init) {\n\t\tthis.init = false;\n\t\tthis.sink.event(t, this.value);\n\t}\n\n\tvar f = this.f;\n\tthis.value = f(this.value, x);\n\tthis.sink.event(t, this.value);\n};\n\nScanSink.prototype.error = Pipe.prototype.error;\nScanSink.prototype.end = Pipe.prototype.end;\n\n/**\n * Reduce a stream to produce a single result.  Note that reducing an infinite\n * stream will return a Promise that never fulfills, but that may reject if an error\n * occurs.\n * @param {function(result:*, x:*):*} f reducer function\n * @param {*} initial initial value\n * @param {Stream} stream to reduce\n * @returns {Promise} promise for the file result of the reduce\n */\nfunction reduce(f, initial, stream) {\n\treturn runSource.withDefaultScheduler(noop, new Accumulate(f, initial, stream.source));\n}\n\nfunction Accumulate(f, z, source) {\n\tthis.f = f;\n\tthis.value = z;\n\tthis.source = source;\n}\n\nAccumulate.prototype.run = function(sink, scheduler) {\n\treturn this.source.run(new AccumulateSink(this.f, this.value, sink), scheduler);\n};\n\nfunction AccumulateSink(f, z, sink) {\n\tthis.f = f;\n\tthis.value = z;\n\tthis.sink = sink;\n}\n\nAccumulateSink.prototype.event = function(t, x) {\n\tvar f = this.f;\n\tthis.value = f(this.value, x);\n\tthis.sink.event(t, this.value);\n};\n\nAccumulateSink.prototype.error = Pipe.prototype.error;\n\nAccumulateSink.prototype.end = function(t) {\n\tthis.sink.end(t, this.value);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/accumulate.js\n ** module id = 49\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Promise = require('../Promise');\n\nexports.unfold = unfold;\n\n/**\n * Compute a stream by unfolding tuples of future values from a seed value\n * Event times may be controlled by returning a Promise from f\n * @param {function(seed:*):{value:*, seed:*, done:boolean}|Promise<{value:*, seed:*, done:boolean}>} f unfolding function accepts\n *  a seed and returns a new tuple with a value, new seed, and boolean done flag.\n *  If tuple.done is true, the stream will end.\n * @param {*} seed seed value\n * @returns {Stream} stream containing all value of all tuples produced by the\n *  unfolding function.\n */\nfunction unfold(f, seed) {\n\treturn new Stream(new UnfoldSource(f, seed));\n}\n\nfunction UnfoldSource(f, seed) {\n\tthis.f = f;\n\tthis.value = seed;\n}\n\nUnfoldSource.prototype.run = function(sink, scheduler) {\n\treturn new Unfold(this.f, this.value, sink, scheduler);\n};\n\nfunction Unfold(f, x, sink, scheduler) {\n\tthis.f = f;\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n\tthis.active = true;\n\n\tvar self = this;\n\tfunction err(e) {\n\t\tself.sink.error(self.scheduler.now(), e);\n\t}\n\n\tfunction start(unfold) {\n\t\treturn stepUnfold(unfold, x);\n\t}\n\n\tPromise.resolve(this).then(start).catch(err);\n}\n\nUnfold.prototype.dispose = function() {\n\tthis.active = false;\n};\n\nfunction stepUnfold(unfold, x) {\n\tvar f = unfold.f;\n\treturn Promise.resolve(f(x)).then(function(tuple) {\n\t\treturn continueUnfold(unfold, tuple);\n\t});\n}\n\nfunction continueUnfold(unfold, tuple) {\n\tif(tuple.done) {\n\t\tunfold.sink.end(unfold.scheduler.now(), tuple.value);\n\t\treturn tuple.value;\n\t}\n\n\tunfold.sink.event(unfold.scheduler.now(), tuple.value);\n\n\tif(!unfold.active) {\n\t\treturn tuple.value;\n\t}\n\treturn stepUnfold(unfold, tuple.seed);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/unfold.js\n ** module id = 50\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Promise = require('../Promise');\n\nexports.iterate = iterate;\n\n/**\n * Compute a stream by iteratively calling f to produce values\n * Event times may be controlled by returning a Promise from f\n * @param {function(x:*):*|Promise<*>} f\n * @param {*} x initial value\n * @returns {Stream}\n */\nfunction iterate(f, x) {\n\treturn new Stream(new IterateSource(f, x));\n}\n\nfunction IterateSource(f, x) {\n\tthis.f = f;\n\tthis.value = x;\n}\n\nIterateSource.prototype.run = function(sink, scheduler) {\n\treturn new Iterate(this.f, this.value, sink, scheduler);\n};\n\nfunction Iterate(f, initial, sink, scheduler) {\n\tthis.f = f;\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n\tthis.active = true;\n\n\tvar x = initial;\n\n\tvar self = this;\n\tfunction err(e) {\n\t\tself.sink.error(self.scheduler.now(), e);\n\t}\n\n\tfunction start(iterate) {\n\t\treturn stepIterate(iterate, x);\n\t}\n\n\tPromise.resolve(this).then(start).catch(err);\n}\n\nIterate.prototype.dispose = function() {\n\tthis.active = false;\n};\n\nfunction stepIterate(iterate, x) {\n\titerate.sink.event(iterate.scheduler.now(), x);\n\n\tif(!iterate.active) {\n\t\treturn x;\n\t}\n\n\tvar f = iterate.f;\n\treturn Promise.resolve(f(x)).then(function(y) {\n\t\treturn continueIterate(iterate, y);\n\t});\n}\n\nfunction continueIterate(iterate, x) {\n\treturn !iterate.active ? iterate.value : stepIterate(iterate, x);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/iterate.js\n ** module id = 51\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Promise = require('../Promise');\nvar base = require('../base');\n\nexports.generate = generate;\n\n/**\n * Compute a stream using an *async* generator, which yields promises\n * to control event times.\n * @param f\n * @returns {Stream}\n */\nfunction generate(f /*, ...args */) {\n\treturn new Stream(new GenerateSource(f, base.tail(arguments)));\n}\n\nfunction GenerateSource(f, args) {\n\tthis.f = f;\n\tthis.args = args;\n}\n\nGenerateSource.prototype.run = function(sink, scheduler) {\n\treturn new Generate(this.f.apply(void 0, this.args), sink, scheduler);\n};\n\nfunction Generate(iterator, sink, scheduler) {\n\tthis.iterator = iterator;\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n\tthis.active = true;\n\n\tvar self = this;\n\tfunction err(e) {\n\t\tself.sink.error(self.scheduler.now(), e);\n\t}\n\n\tPromise.resolve(this).then(next).catch(err);\n}\n\nfunction next(generate, x) {\n\treturn generate.active ? handle(generate, generate.iterator.next(x)) : x;\n}\n\nfunction handle(generate, result) {\n\tif (result.done) {\n\t\treturn generate.sink.end(generate.scheduler.now(), result.value);\n\t}\n\n\treturn Promise.resolve(result.value).then(function (x) {\n\t\treturn emit(generate, x);\n\t}, function(e) {\n\t\treturn error(generate, e);\n\t});\n}\n\nfunction emit(generate, x) {\n\tgenerate.sink.event(generate.scheduler.now(), x);\n\treturn next(generate, x);\n}\n\nfunction error(generate, e) {\n\treturn handle(generate, generate.iterator.throw(e));\n}\n\nGenerate.prototype.dispose = function() {\n\tthis.active = false;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/source/generate.js\n ** module id = 52\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar streamOf = require('../source/core').of;\nvar fromArray = require('../source/fromArray').fromArray;\nvar concatMap = require('./concatMap').concatMap;\nvar Sink = require('../sink/Pipe');\nvar Promise = require('../Promise');\nvar identity = require('../base').identity;\n\nexports.concat = concat;\nexports.cycle = cycle;\nexports.cons = cons;\n\n/**\n * @param {*} x value to prepend\n * @param {Stream} stream\n * @returns {Stream} new stream with x prepended\n */\nfunction cons(x, stream) {\n\treturn concat(streamOf(x), stream);\n}\n\n/**\n * @param {Stream} left\n * @param {Stream} right\n * @returns {Stream} new stream containing all events in left followed by all\n *  events in right.  This *timeshifts* right to the end of left.\n */\nfunction concat(left, right) {\n\treturn concatMap(identity, fromArray([left, right]));\n}\n\n/**\n * Tie stream into a circle, thus creating an infinite stream\n * @param {Stream} stream\n * @returns {Stream} new infinite stream\n */\nfunction cycle(stream) {\n\treturn new Stream(new Cycle(stream.source));\n}\n\nfunction Cycle(source) {\n\tthis.source = source;\n}\n\nCycle.prototype.run = function(sink, scheduler) {\n\treturn new CycleSink(this.source, sink, scheduler);\n};\n\nfunction CycleSink(source, sink, scheduler) {\n\tthis.active = true;\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n\tthis.source = source;\n\tthis.disposable = source.run(this, scheduler);\n}\n\nCycleSink.prototype.error = Sink.prototype.error;\n\nCycleSink.prototype.event = function(t, x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\tthis.sink.event(t, x);\n};\n\nCycleSink.prototype.end = function(t) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\n\tvar self = this;\n\tPromise.resolve(this.disposable.dispose()).catch(function(e) {\n\t\tself.error(t, e);\n\t});\n\tthis.disposable = this.source.run(this, this.scheduler);\n};\n\nCycleSink.prototype.dispose = function() {\n\tthis.active = false;\n\treturn this.disposable.dispose();\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/build.js\n ** module id = 53\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar mergeConcurrently = require('./mergeConcurrently').mergeConcurrently;\nvar map = require('./transform').map;\n\nexports.concatMap = concatMap;\n\n/**\n * Map each value in stream to a new stream, and concatenate them all\n * stream:              -a---b---cX\n * f(a):                 1-1-1-1X\n * f(b):                        -2-2-2-2X\n * f(c):                                -3-3-3-3X\n * stream.concatMap(f): -1-1-1-1-2-2-2-2-3-3-3-3X\n * @param {function(x:*):Stream} f function to map each value to a stream\n * @param {Stream} stream\n * @returns {Stream} new stream containing all events from each stream returned by f\n */\nfunction concatMap(f, stream) {\n\treturn mergeConcurrently(1, map(f, stream));\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/concatMap.js\n ** module id = 54\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar AwaitingDisposable = require('../disposable/AwaitingDisposable');\nvar LinkedList = require('../LinkedList');\nvar Promise = require('../Promise');\n\nexports.mergeConcurrently = mergeConcurrently;\n\nfunction mergeConcurrently(concurrency, stream) {\n\treturn new Stream(new MergeConcurrently(concurrency, stream.source));\n}\n\nfunction MergeConcurrently(concurrency, source) {\n\tthis.concurrency = concurrency;\n\tthis.source = source;\n}\n\nMergeConcurrently.prototype.run = function(sink, scheduler) {\n\treturn new Outer(this.concurrency, this.source, sink, scheduler);\n};\n\nfunction Outer(concurrency, source, sink, scheduler) {\n\tthis.concurrency = concurrency;\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n\tthis.pending = [];\n\tthis.current = new LinkedList();\n\tthis.disposable = new AwaitingDisposable(source.run(this, scheduler));\n\tthis.active = true;\n}\n\nOuter.prototype.event = function(t, x) {\n\tthis._addInner(t, x);\n};\n\nOuter.prototype._addInner = function(t, stream) {\n\tif(this.current.length < this.concurrency) {\n\t\tthis._startInner(t, stream);\n\t} else {\n\t\tthis.pending.push(stream);\n\t}\n};\n\nOuter.prototype._startInner = function(t, stream) {\n\tvar innerSink = new Inner(t, this, this.sink);\n\tthis.current.add(innerSink);\n\tinnerSink.disposable = stream.source.run(innerSink, this.scheduler);\n};\n\nOuter.prototype.end = function(t, x) {\n\tthis.active = false;\n\tthis.disposable.dispose();\n\tthis._checkEnd(t, x);\n};\n\nOuter.prototype.error = function(t, e) {\n\tthis.active = false;\n\tthis.sink.error(t, e);\n};\n\nOuter.prototype.dispose = function() {\n\tthis.active = false;\n\tthis.pending.length = 0;\n\treturn Promise.all([this.disposable.dispose(), this.current.dispose()]);\n};\n\nOuter.prototype._endInner = function(t, x, inner) {\n\tthis.current.remove(inner);\n\tvar self = this;\n\tPromise.resolve(inner.dispose()).catch(function(e) {\n\t\tself.error(t, e);\n\t});\n\n\tif(this.pending.length === 0) {\n\t\tthis._checkEnd(t, x);\n\t} else {\n\t\tthis._startInner(t, this.pending.shift());\n\t}\n};\n\nOuter.prototype._checkEnd = function(t, x) {\n\tif(!this.active && this.current.isEmpty()) {\n\t\tthis.sink.end(t, x);\n\t}\n};\n\nfunction Inner(time, outer, sink) {\n\tthis.prev = this.next = null;\n\tthis.time = time;\n\tthis.outer = outer;\n\tthis.sink = sink;\n\tthis.disposable = void 0;\n}\n\nInner.prototype.event = function(t, x) {\n\tthis.sink.event(Math.max(t, this.time), x);\n};\n\nInner.prototype.end = function(t, x) {\n\tthis.outer._endInner(Math.max(t, this.time), x, this);\n};\n\nInner.prototype.error = function(t, e) {\n\tthis.outer.error(Math.max(t, this.time), e);\n};\n\nInner.prototype.dispose = function() {\n\treturn this.disposable.dispose();\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/mergeConcurrently.js\n ** module id = 55\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nmodule.exports = AwaitingDisposable;\n\nfunction AwaitingDisposable(disposable) {\n\tthis.disposed = false;\n\tthis.disposable = disposable;\n\tthis.value = void 0;\n}\n\nAwaitingDisposable.prototype.dispose = function() {\n\tif(!this.disposed) {\n\t\tthis.disposed = true;\n\t\tthis.value = this.disposable.dispose();\n\t}\n\treturn this.value;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/disposable/AwaitingDisposable.js\n ** module id = 56\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Promise = require('./Promise');\n\nmodule.exports = LinkedList;\n\n/**\n * Doubly linked list\n * @constructor\n */\nfunction LinkedList() {\n\tthis.head = null;\n\tthis.length = 0;\n}\n\n/**\n * Add a node to the end of the list\n * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to add\n */\nLinkedList.prototype.add = function(x) {\n\tif(this.head !== null) {\n\t\tthis.head.prev = x;\n\t\tx.next = this.head;\n\t}\n\tthis.head = x;\n\t++this.length;\n};\n\n/**\n * Remove the provided node from the list\n * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to remove\n */\nLinkedList.prototype.remove = function(x) {\n\t--this.length;\n\tif(x === this.head) {\n\t\tthis.head = this.head.next;\n\t}\n\tif(x.next !== null) {\n\t\tx.next.prev = x.prev;\n\t\tx.next = null;\n\t}\n\tif(x.prev !== null) {\n\t\tx.prev.next = x.next;\n\t\tx.prev = null;\n\t}\n};\n\n/**\n * @returns {boolean} true iff there are no nodes in the list\n */\nLinkedList.prototype.isEmpty = function() {\n\treturn this.length === 0;\n};\n\n/**\n * Dispose all nodes\n * @returns {Promise} promise that fulfills when all nodes have been disposed,\n *  or rejects if an error occurs while disposing\n */\nLinkedList.prototype.dispose = function() {\n\tif(this.isEmpty()) {\n\t\treturn Promise.resolve();\n\t}\n\n\tvar promises = [];\n\tvar x = this.head;\n\tthis.head = null;\n\tthis.length = 0;\n\n\twhile(x !== null) {\n\t\tpromises.push(x.dispose());\n\t\tx = x.next;\n\t}\n\n\treturn Promise.all(promises);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/LinkedList.js\n ** module id = 57\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar combine = require('./combine').combine;\n\nexports.ap  = ap;\n\n/**\n * Assume fs is a stream containing functions, and apply the latest function\n * in fs to the latest value in xs.\n * fs:         --f---------g--------h------>\n * xs:         -a-------b-------c-------d-->\n * ap(fs, xs): --fa-----fb-gb---gc--hc--hd->\n * @param {Stream} fs stream of functions to apply to the latest x\n * @param {Stream} xs stream of values to which to apply all the latest f\n * @returns {Stream} stream containing all the applications of fs to xs\n */\nfunction ap(fs, xs) {\n\treturn combine(apply, fs, xs);\n}\n\nfunction apply(f, x) {\n\treturn f(x);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/applicative.js\n ** module id = 58\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\n\nexports.transduce = transduce;\n\n/**\n * Transform a stream by passing its events through a transducer.\n * @param  {function} transducer transducer function\n * @param  {Stream} stream stream whose events will be passed through the\n *  transducer\n * @return {Stream} stream of events transformed by the transducer\n */\nfunction transduce(transducer, stream) {\n\treturn new Stream(new Transduce(transducer, stream.source));\n}\n\nfunction Transduce(transducer, source) {\n\tthis.transducer = transducer;\n\tthis.source = source;\n}\n\nTransduce.prototype.run = function(sink, scheduler) {\n\tvar xf = this.transducer(new Transformer(sink));\n\treturn this.source.run(new TransduceSink(getTxHandler(xf), sink), scheduler);\n};\n\nfunction TransduceSink(adapter, sink) {\n\tthis.xf = adapter;\n\tthis.sink = sink;\n}\n\nTransduceSink.prototype.event = function(t, x) {\n\tvar next = this.xf.step(t, x);\n\n\treturn this.xf.isReduced(next)\n\t\t? this.sink.end(t, this.xf.getResult(next))\n\t\t: next;\n};\n\nTransduceSink.prototype.end = function(t, x) {\n\treturn this.xf.result(x);\n};\n\nTransduceSink.prototype.error = function(t, e) {\n\treturn this.sink.error(t, e);\n};\n\nfunction Transformer(sink) {\n\tthis.time = -Infinity;\n\tthis.sink = sink;\n}\n\nTransformer.prototype['@@transducer/init'] = Transformer.prototype.init = function() {};\n\nTransformer.prototype['@@transducer/step'] = Transformer.prototype.step = function(t, x) {\n\tif(!isNaN(t)) {\n\t\tthis.time = Math.max(t, this.time);\n\t}\n\treturn this.sink.event(this.time, x);\n};\n\nTransformer.prototype['@@transducer/result'] = Transformer.prototype.result = function(x) {\n\treturn this.sink.end(this.time, x);\n};\n\n/**\n * Given an object supporting the new or legacy transducer protocol,\n * create an adapter for it.\n * @param {object} tx transform\n * @returns {TxAdapter|LegacyTxAdapter}\n */\nfunction getTxHandler(tx) {\n\treturn typeof tx['@@transducer/step'] === 'function'\n\t\t? new TxAdapter(tx)\n\t\t: new LegacyTxAdapter(tx);\n}\n\n/**\n * Adapter for new official transducer protocol\n * @param {object} tx transform\n * @constructor\n */\nfunction TxAdapter(tx) {\n\tthis.tx = tx;\n}\n\nTxAdapter.prototype.step = function(t, x) {\n\treturn this.tx['@@transducer/step'](t, x);\n};\nTxAdapter.prototype.result = function(x) {\n\treturn this.tx['@@transducer/result'](x);\n};\nTxAdapter.prototype.isReduced = function(x) {\n\treturn x != null && x['@@transducer/reduced'];\n};\nTxAdapter.prototype.getResult = function(x) {\n\treturn x['@@transducer/value'];\n};\n\n/**\n * Adapter for older transducer protocol\n * @param {object} tx transform\n * @constructor\n */\nfunction LegacyTxAdapter(tx) {\n\tthis.tx = tx;\n}\n\nLegacyTxAdapter.prototype.step = function(t, x) {\n\treturn this.tx.step(t, x);\n};\nLegacyTxAdapter.prototype.result = function(x) {\n\treturn this.tx.result(x);\n};\nLegacyTxAdapter.prototype.isReduced = function(x) {\n\treturn x != null && x.__transducers_reduced__;\n};\nLegacyTxAdapter.prototype.getResult = function(x) {\n\treturn x.value;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/transduce.js\n ** module id = 59\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar mergeConcurrently = require('./mergeConcurrently').mergeConcurrently;\nvar map = require('./transform').map;\n\nexports.flatMap = flatMap;\nexports.join = join;\n\n/**\n * Map each value in the stream to a new stream, and merge it into the\n * returned outer stream. Event arrival times are preserved.\n * @param {function(x:*):Stream} f chaining function, must return a Stream\n * @param {Stream} stream\n * @returns {Stream} new stream containing all events from each stream returned by f\n */\nfunction flatMap(f, stream) {\n\treturn join(map(f, stream));\n}\n\n/**\n * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner\n * streams to the outer. Event arrival times are preserved.\n * @param {Stream<Stream<X>>} stream stream of streams\n * @returns {Stream<X>} new stream containing all events of all inner streams\n */\nfunction join(stream) {\n\treturn mergeConcurrently(Infinity, stream);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/flatMap.js\n ** module id = 60\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Sink = require('../sink/Pipe');\nvar AwaitingDisposable = require('../disposable/AwaitingDisposable');\nvar CompoundDisposable = require('../disposable/CompoundDisposable');\n\nexports.flatMapEnd = flatMapEnd;\n\nfunction flatMapEnd(f, stream) {\n\treturn new Stream(new FlatMapEnd(f, stream.source));\n}\n\nfunction FlatMapEnd(f, source) {\n\tthis.f = f;\n\tthis.source = source;\n}\n\nFlatMapEnd.prototype.run = function(sink, scheduler) {\n\treturn new FlatMapEndSink(this.f, this.source, sink, scheduler);\n};\n\nfunction FlatMapEndSink(f, source, sink, scheduler) {\n\tthis.f = f;\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n\tthis.active = true;\n\tthis.disposable = new AwaitingDisposable(source.run(this, scheduler));\n}\n\nFlatMapEndSink.prototype.error = Sink.prototype.error;\n\nFlatMapEndSink.prototype.event = function(t, x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\tthis.sink.event(t, x);\n};\n\nFlatMapEndSink.prototype.end = function(t, x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\n\tthis.dispose();\n\n\tvar f = this.f;\n\tvar stream = f(x);\n\tvar disposable = stream.source.run(this.sink, this.scheduler);\n\tthis.disposable = new CompoundDisposable([this.disposable, disposable]);\n};\n\nFlatMapEndSink.prototype.dispose = function() {\n\tthis.active = false;\n\treturn this.disposable.dispose();\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/flatMapEnd.js\n ** module id = 61\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar empty = require('../Stream').empty;\nvar fromArray = require('../source/fromArray').fromArray;\nvar mergeConcurrently = require('./mergeConcurrently').mergeConcurrently;\nvar copy = require('../base').copy;\n\nexports.merge = merge;\nexports.mergeArray = mergeArray;\n\n/**\n * @returns {Stream} stream containing events from all streams in the argument\n * list in time order.  If two events are simultaneous they will be merged in\n * arbitrary order.\n */\nfunction merge(/*...streams*/) {\n\treturn mergeArray(copy(arguments));\n}\n\n/**\n * @param {Array} streams array of stream to merge\n * @returns {Stream} stream containing events from all input observables\n * in time order.  If two events are simultaneous they will be merged in\n * arbitrary order.\n */\nfunction mergeArray(streams) {\n\tvar l = streams.length;\n    return l === 0 ? empty()\n\t\t : l === 1 ? streams[0]\n\t\t : mergeConcurrently(l, fromArray(streams));\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/merge.js\n ** module id = 62\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Pipe = require('../sink/Pipe');\nvar CompoundDisposable = require('../disposable/CompoundDisposable');\nvar base = require('../base');\nvar invoke = require('../invoke');\n\nexports.sample = sample;\nexports.sampleWith = sampleWith;\nexports.sampleArray = sampleArray;\n\n/**\n * When an event arrives on sampler, emit the result of calling f with the latest\n * values of all streams being sampled\n * @param {function(...values):*} f function to apply to each set of sampled values\n * @param {Stream} sampler streams will be sampled whenever an event arrives\n *  on sampler\n * @returns {Stream} stream of sampled and transformed values\n */\nfunction sample(f, sampler /*, ...streams */) {\n\treturn sampleArray(f, sampler, base.drop(2, arguments));\n}\n\n/**\n * When an event arrives on sampler, emit the latest event value from stream.\n * @param {Stream} sampler stream of events at whose arrival time\n *  stream's latest value will be propagated\n * @param {Stream} stream stream of values\n * @returns {Stream} sampled stream of values\n */\nfunction sampleWith(sampler, stream) {\n\treturn new Stream(new Sampler(base.identity, sampler.source, [stream.source]));\n}\n\nfunction sampleArray(f, sampler, streams) {\n\treturn new Stream(new Sampler(f, sampler.source, base.map(getSource, streams)));\n}\n\nfunction getSource(stream) {\n\treturn stream.source;\n}\n\nfunction Sampler(f, sampler, sources) {\n\tthis.f = f;\n\tthis.sampler = sampler;\n\tthis.sources = sources;\n}\n\nSampler.prototype.run = function(sink, scheduler) {\n\tvar l = this.sources.length;\n\tvar disposables = new Array(l+1);\n\tvar sinks = new Array(l);\n\n\tvar sampleSink = new SampleSink(this.f, sinks, sink);\n\n\tfor(var hold, i=0; i<l; ++i) {\n\t\thold = sinks[i] = new Hold(sampleSink);\n\t\tdisposables[i] = this.sources[i].run(hold, scheduler);\n\t}\n\n\tdisposables[i] = this.sampler.run(sampleSink, scheduler);\n\n\treturn new CompoundDisposable(disposables);\n};\n\nfunction Hold(sink) {\n\tthis.sink = sink;\n\tthis.hasValue = false;\n}\n\nHold.prototype.event = function(t, x) {\n\tthis.value = x;\n\tthis.hasValue = true;\n\tthis.sink._notify(this);\n};\n\nHold.prototype.end = base.noop;\nHold.prototype.error = Pipe.prototype.error;\n\nfunction SampleSink(f, sinks, sink) {\n\tthis.f = f;\n\tthis.sinks = sinks;\n\tthis.sink = sink;\n\tthis.active = false;\n}\n\nSampleSink.prototype._notify = function() {\n\tif(!this.active) {\n\t\tthis.active = this.sinks.every(hasValue);\n\t}\n};\n\nSampleSink.prototype.event = function(t) {\n\tif(this.active) {\n\t\tthis.sink.event(t, invoke(this.f, base.map(getValue, this.sinks)));\n\t}\n};\n\nSampleSink.prototype.end = Pipe.prototype.end;\nSampleSink.prototype.error = Pipe.prototype.error;\n\nfunction hasValue(hold) {\n\treturn hold.hasValue;\n}\n\nfunction getValue(hold) {\n\treturn hold.value;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/sample.js\n ** module id = 63\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar transform = require('./transform');\nvar core = require('../source/core');\nvar Sink = require('../sink/Pipe');\nvar IndexSink = require('../sink/IndexSink');\nvar CompoundDisposable = require('../disposable/CompoundDisposable');\nvar base = require('../base');\nvar invoke = require('../invoke');\nvar Queue = require('../Queue');\n\nvar map = base.map;\nvar tail = base.tail;\n\nexports.zip = zip;\nexports.zipArray = zipArray;\n\n/**\n * Combine streams pairwise (or tuple-wise) by index by applying f to values\n * at corresponding indices.  The returned stream ends when any of the input\n * streams ends.\n * @param {function} f function to combine values\n * @returns {Stream} new stream with items at corresponding indices combined\n *  using f\n */\nfunction zip(f /*,...streams */) {\n\treturn zipArray(f, tail(arguments));\n}\n\n/**\n * Combine streams pairwise (or tuple-wise) by index by applying f to values\n * at corresponding indices.  The returned stream ends when any of the input\n * streams ends.\n * @param {function} f function to combine values\n * @param {[Stream]} streams streams to zip using f\n * @returns {Stream} new stream with items at corresponding indices combined\n *  using f\n */\nfunction zipArray(f, streams) {\n\treturn streams.length === 0 ? core.empty()\n\t\t : streams.length === 1 ? transform.map(f, streams[0])\n\t\t : new Stream(new Zip(f, map(getSource, streams)));\n}\n\nfunction getSource(stream) {\n\treturn stream.source;\n}\n\nfunction Zip(f, sources) {\n\tthis.f = f;\n\tthis.sources = sources;\n}\n\nZip.prototype.run = function(sink, scheduler) {\n\tvar l = this.sources.length;\n\tvar disposables = new Array(l);\n\tvar sinks = new Array(l);\n\tvar buffers = new Array(l);\n\n\tvar zipSink = new ZipSink(this.f, buffers, sinks, sink);\n\n\tfor(var indexSink, i=0; i<l; ++i) {\n\t\tbuffers[i] = new Queue();\n\t\tindexSink = sinks[i] = new IndexSink(i, zipSink);\n\t\tdisposables[i] = this.sources[i].run(indexSink, scheduler);\n\t}\n\n\treturn new CompoundDisposable(disposables);\n};\n\nfunction ZipSink(f, buffers, sinks, sink) {\n\tthis.f = f;\n\tthis.sinks = sinks;\n\tthis.sink = sink;\n\tthis.buffers = buffers;\n}\n\nZipSink.prototype.event = function(t, indexedValue) {\n\tvar buffers = this.buffers;\n\tvar buffer = buffers[indexedValue.index];\n\n\tbuffer.push(indexedValue.value);\n\n\tif(buffer.length() === 1) {\n\t\tif(!ready(this.buffers)) {\n\t\t\treturn;\n\t\t}\n\n\t\temitZipped(this.f, t, buffers, this.sink);\n\n\t\tif (ended(this.buffers, this.sinks)) {\n\t\t\tthis.sink.end(t, void 0);\n\t\t}\n\t}\n};\n\nZipSink.prototype.end = function(t, indexedValue) {\n\tvar buffer = this.buffers[indexedValue.index];\n\tif(buffer.isEmpty()) {\n\t\tthis.sink.end(t, indexedValue.value);\n\t}\n};\n\nZipSink.prototype.error = Sink.prototype.error;\n\nfunction emitZipped (f, t, buffers, sink) {\n\tsink.event(t, invoke(f, map(head, buffers)));\n}\n\nfunction head(buffer) {\n\treturn buffer.shift();\n}\n\nfunction ended(buffers, sinks) {\n\tfor(var i=0, l=buffers.length; i<l; ++i) {\n\t\tif(buffers[i].isEmpty() && !sinks[i].active) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction ready(buffers) {\n\tfor(var i=0, l=buffers.length; i<l; ++i) {\n\t\tif(buffers[i].isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/zip.js\n ** module id = 64\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n// Based on https://github.com/petkaantonov/deque\n\nmodule.exports = Queue;\n\nfunction Queue(capPow2) {\n\tthis._capacity = capPow2||32;\n\tthis._length = 0;\n\tthis._head = 0;\n}\n\nQueue.prototype.push = function (x) {\n\tvar len = this._length;\n\tthis._checkCapacity(len + 1);\n\n\tvar i = (this._head + len) & (this._capacity - 1);\n\tthis[i] = x;\n\tthis._length = len + 1;\n};\n\nQueue.prototype.shift = function () {\n\tvar head = this._head;\n\tvar x = this[head];\n\n\tthis[head] = void 0;\n\tthis._head = (head + 1) & (this._capacity - 1);\n\tthis._length--;\n\treturn x;\n};\n\nQueue.prototype.isEmpty = function() {\n\treturn this._length === 0;\n};\n\nQueue.prototype.length = function () {\n\treturn this._length;\n};\n\nQueue.prototype._checkCapacity = function (size) {\n\tif (this._capacity < size) {\n\t\tthis._ensureCapacity(this._capacity << 1);\n\t}\n};\n\nQueue.prototype._ensureCapacity = function (capacity) {\n\tvar oldCapacity = this._capacity;\n\tthis._capacity = capacity;\n\n\tvar last = this._head + this._length;\n\n\tif (last > oldCapacity) {\n\t\tcopy(this, 0, this, oldCapacity, last & (oldCapacity - 1));\n\t}\n};\n\nfunction copy(src, srcIndex, dst, dstIndex, len) {\n\tfor (var j = 0; j < len; ++j) {\n\t\tdst[j + dstIndex] = src[j + srcIndex];\n\t\tsrc[j + srcIndex] = void 0;\n\t}\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/Queue.js\n ** module id = 65\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar MulticastSource = require('../source/MulticastSource');\nvar until = require('./timeslice').takeUntil;\nvar mergeConcurrently = require('./mergeConcurrently').mergeConcurrently;\nvar map = require('./transform').map;\n\nexports.switch = switchLatest;\n\n/**\n * Given a stream of streams, return a new stream that adopts the behavior\n * of the most recent inner stream.\n * @param {Stream} stream of streams on which to switch\n * @returns {Stream} switching stream\n */\nfunction switchLatest(stream) {\n\tvar upstream = new Stream(new MulticastSource(stream.source));\n\n\treturn mergeConcurrently(1, map(untilNext, upstream));\n\n\tfunction untilNext(s) {\n\t\treturn until(upstream, s);\n\t}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/switch.js\n ** module id = 66\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Pipe = require('../sink/Pipe');\nvar CompoundDisposable = require('../disposable/CompoundDisposable');\nvar never = require('../source/core').never;\nvar join = require('../combinator/flatMap').join;\nvar take = require('../combinator/slice').take;\nvar noop = require('../base').noop;\n\nexports.during    = during;\nexports.takeUntil = takeUntil;\nexports.skipUntil = skipUntil;\n\nfunction takeUntil(signal, stream) {\n\treturn new Stream(new Until(signal.source, stream.source));\n}\n\nfunction skipUntil(signal, stream) {\n\treturn between(signal, never(), stream);\n}\n\nfunction during(timeWindow, stream) {\n\treturn between(timeWindow, join(timeWindow), stream);\n}\n\nfunction between(start, end, stream) {\n\treturn new Stream(new During(take(1, start).source, take(1, end).source, stream.source));\n}\n\nfunction Until(maxSignal, source) {\n\tthis.maxSignal = maxSignal;\n\tthis.source = source;\n}\n\nUntil.prototype.run = function(sink, scheduler) {\n\tvar min = new MinBound(sink);\n\tvar max = new UpperBound(this.maxSignal, sink, scheduler);\n\tvar disposable = this.source.run(new TimeWindowSink(min, max, sink), scheduler);\n\n\treturn new CompoundDisposable([min, max, disposable]);\n};\n\nfunction MinBound(sink) {\n\tthis.value = -Infinity;\n\tthis.sink = sink;\n}\n\nMinBound.prototype.error = Pipe.prototype.error;\nMinBound.prototype.event = noop;\nMinBound.prototype.end = noop;\nMinBound.prototype.dispose = noop;\n\nfunction During(minSignal, maxSignal, source) {\n\tthis.minSignal = minSignal;\n\tthis.maxSignal = maxSignal;\n\tthis.source = source;\n}\n\nDuring.prototype.run = function(sink, scheduler) {\n\tvar min = new LowerBound(this.minSignal, sink, scheduler);\n\tvar max = new UpperBound(this.maxSignal, sink, scheduler);\n\tvar disposable = this.source.run(new TimeWindowSink(min, max, sink), scheduler);\n\n\treturn new CompoundDisposable([min, max, disposable]);\n};\n\nfunction TimeWindowSink(min, max, sink) {\n\tthis.min = min;\n\tthis.max = max;\n\tthis.sink = sink;\n}\n\nTimeWindowSink.prototype.event = function(t, x) {\n\tif(t >= this.min.value && t < this.max.value) {\n\t\tthis.sink.event(t, x);\n\t}\n};\n\nTimeWindowSink.prototype.error = Pipe.prototype.error;\nTimeWindowSink.prototype.end = Pipe.prototype.end;\n\nfunction LowerBound(signal, sink, scheduler) {\n\tthis.value = Infinity;\n\tthis.sink = sink;\n\tthis.disposable = signal.run(this, scheduler);\n}\n\nLowerBound.prototype.event = function(t /*, x */) {\n\tif(t < this.value) {\n\t\tthis.value = t;\n\t}\n};\n\nLowerBound.prototype.end = noop;\nLowerBound.prototype.error = Pipe.prototype.error;\n\nLowerBound.prototype.dispose = function() {\n\treturn this.disposable.dispose();\n};\n\nfunction UpperBound(signal, sink, scheduler) {\n\tthis.value = Infinity;\n\tthis.sink = sink;\n\tthis.disposable = signal.run(this, scheduler);\n}\n\nUpperBound.prototype.event = function(t, x) {\n\tif(t < this.value) {\n\t\tthis.value = t;\n\t\tthis.sink.end(t, x);\n\t}\n};\n\nUpperBound.prototype.end = noop;\nUpperBound.prototype.error = Pipe.prototype.error;\n\nUpperBound.prototype.dispose = function() {\n\treturn this.disposable.dispose();\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/timeslice.js\n ** module id = 67\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Sink = require('../sink/Pipe');\nvar core = require('../source/core');\nvar AwaitingDisposable = require('../disposable/AwaitingDisposable');\n\nexports.take = take;\nexports.skip = skip;\nexports.slice = slice;\nexports.takeWhile = takeWhile;\nexports.skipWhile = skipWhile;\n\n/**\n * @param {number} n\n * @param {Stream} stream\n * @returns {Stream} new stream containing only up to the first n items from stream\n */\nfunction take(n, stream) {\n\treturn slice(0, n, stream);\n}\n\n/**\n * @param {number} n\n * @param {Stream} stream\n * @returns {Stream} new stream with the first n items removed\n */\nfunction skip(n, stream) {\n\treturn slice(n, Infinity, stream);\n}\n\n/**\n * Slice a stream by index. Negative start/end indexes are not supported\n * @param {number} start\n * @param {number} end\n * @param {Stream} stream\n * @returns {Stream} stream containing items where start <= index < end\n */\nfunction slice(start, end, stream) {\n\treturn end <= start ? core.empty()\n\t\t: new Stream(new Slice(start, end, stream.source));\n}\n\nfunction Slice(min, max, source) {\n\tthis.skip = min;\n\tthis.take = max - min;\n\tthis.source = source;\n}\n\nSlice.prototype.run = function(sink, scheduler) {\n\treturn new SliceSink(this.skip, this.take, this.source, sink, scheduler);\n};\n\nfunction SliceSink(skip, take, source, sink, scheduler) {\n\tthis.skip = skip;\n\tthis.take = take;\n\tthis.sink = sink;\n\tthis.disposable = new AwaitingDisposable(source.run(this, scheduler));\n}\n\nSliceSink.prototype.end   = Sink.prototype.end;\nSliceSink.prototype.error = Sink.prototype.error;\n\nSliceSink.prototype.event = function(t, x) {\n\tif(this.skip > 0) {\n\t\tthis.skip -= 1;\n\t\treturn;\n\t}\n\n\tif(this.take === 0) {\n\t\treturn;\n\t}\n\n\tthis.take -= 1;\n\tthis.sink.event(t, x);\n\tif(this.take === 0) {\n\t\tthis.dispose();\n\t\tthis.sink.end(t, x);\n\t}\n};\n\nSliceSink.prototype.dispose = function() {\n\treturn this.disposable.dispose();\n};\n\nfunction takeWhile(p, stream) {\n\treturn new Stream(new TakeWhile(p, stream.source));\n}\n\nfunction TakeWhile(p, source) {\n\tthis.p = p;\n\tthis.source = source;\n}\n\nTakeWhile.prototype.run = function(sink, scheduler) {\n\treturn new TakeWhileSink(this.p, this.source, sink, scheduler);\n};\n\nfunction TakeWhileSink(p, source, sink, scheduler) {\n\tthis.p = p;\n\tthis.sink = sink;\n\tthis.active = true;\n\tthis.disposable = new AwaitingDisposable(source.run(this, scheduler));\n}\n\nTakeWhileSink.prototype.end   = Sink.prototype.end;\nTakeWhileSink.prototype.error = Sink.prototype.error;\n\nTakeWhileSink.prototype.event = function(t, x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\n\tvar p = this.p;\n\tthis.active = p(x);\n\tif(this.active) {\n\t\tthis.sink.event(t, x);\n\t} else {\n\t\tthis.dispose();\n\t\tthis.sink.end(t, x);\n\t}\n};\n\nTakeWhileSink.prototype.dispose = function() {\n\treturn this.disposable.dispose();\n};\n\nfunction skipWhile(p, stream) {\n\treturn new Stream(new SkipWhile(p, stream.source));\n}\n\nfunction SkipWhile(p, source) {\n\tthis.p = p;\n\tthis.source = source;\n}\n\nSkipWhile.prototype.run = function(sink, scheduler) {\n\treturn this.source.run(new SkipWhileSink(this.p, sink), scheduler);\n};\n\nfunction SkipWhileSink(p, sink) {\n\tthis.p = p;\n\tthis.sink = sink;\n\tthis.skipping = true;\n}\n\nSkipWhileSink.prototype.end   = Sink.prototype.end;\nSkipWhileSink.prototype.error = Sink.prototype.error;\n\nSkipWhileSink.prototype.event = function(t, x) {\n\tif(this.skipping) {\n\t\tvar p = this.p;\n\t\tthis.skipping = p(x);\n\t\tif(this.skipping) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tthis.sink.event(t, x);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/slice.js\n ** module id = 68\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Sink = require('../sink/Pipe');\nvar Filter = require('../fusion/Filter');\n\nexports.filter = filter;\nexports.skipRepeats = skipRepeats;\nexports.skipRepeatsWith = skipRepeatsWith;\n\n/**\n * Retain only items matching a predicate\n * @param {function(x:*):boolean} p filtering predicate called for each item\n * @param {Stream} stream stream to filter\n * @returns {Stream} stream containing only items for which predicate returns truthy\n */\nfunction filter(p, stream) {\n\treturn new Stream(Filter.create(p, stream.source));\n}\n\n/**\n * Skip repeated events, using === to detect duplicates\n * @param {Stream} stream stream from which to omit repeated events\n * @returns {Stream} stream without repeated events\n */\nfunction skipRepeats(stream) {\n\treturn skipRepeatsWith(same, stream);\n}\n\n/**\n * Skip repeated events using the provided equals function to detect duplicates\n * @param {function(a:*, b:*):boolean} equals optional function to compare items\n * @param {Stream} stream stream from which to omit repeated events\n * @returns {Stream} stream without repeated events\n */\nfunction skipRepeatsWith(equals, stream) {\n\treturn new Stream(new SkipRepeats(equals, stream.source));\n}\n\nfunction SkipRepeats(equals, source) {\n\tthis.equals = equals;\n\tthis.source = source;\n}\n\nSkipRepeats.prototype.run = function(sink, scheduler) {\n\treturn this.source.run(new SkipRepeatsSink(this.equals, sink), scheduler);\n};\n\nfunction SkipRepeatsSink(equals, sink) {\n\tthis.equals = equals;\n\tthis.sink = sink;\n\tthis.value = void 0;\n\tthis.init = true;\n}\n\nSkipRepeatsSink.prototype.end   = Sink.prototype.end;\nSkipRepeatsSink.prototype.error = Sink.prototype.error;\n\nSkipRepeatsSink.prototype.event = function(t, x) {\n\tif(this.init) {\n\t\tthis.init = false;\n\t\tthis.value = x;\n\t\tthis.sink.event(t, x);\n\t} else if(!this.equals(this.value, x)) {\n\t\tthis.value = x;\n\t\tthis.sink.event(t, x);\n\t}\n};\n\nfunction same(a, b) {\n\treturn a === b;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/filter.js\n ** module id = 69\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Sink = require('../sink/Pipe');\nvar CompoundDisposable = require('../disposable/CompoundDisposable');\nvar PropagateTask = require('../scheduler/PropagateTask');\n\nexports.delay = delay;\n\n/**\n * @param {Number} delayTime milliseconds to delay each item\n * @param {Stream} stream\n * @returns {Stream} new stream containing the same items, but delayed by ms\n */\nfunction delay(delayTime, stream) {\n\treturn delayTime <= 0 ? stream\n\t\t : new Stream(new Delay(delayTime, stream.source));\n}\n\nfunction Delay(dt, source) {\n\tthis.dt = dt;\n\tthis.source = source;\n}\n\nDelay.prototype.run = function(sink, scheduler) {\n\tvar delaySink = new DelaySink(this.dt, sink, scheduler);\n\treturn new CompoundDisposable([delaySink, this.source.run(delaySink, scheduler)]);\n};\n\nfunction DelaySink(dt, sink, scheduler) {\n\tthis.dt = dt;\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n}\n\nDelaySink.prototype.dispose = function() {\n\tvar self = this;\n\tthis.scheduler.cancelAll(function(task) {\n\t\treturn task.sink === self.sink;\n\t});\n};\n\nDelaySink.prototype.event = function(t, x) {\n\tthis.scheduler.delay(this.dt, PropagateTask.event(x, this.sink));\n};\n\nDelaySink.prototype.end = function(t, x) {\n\tthis.scheduler.delay(this.dt, PropagateTask.end(x, this.sink));\n};\n\nDelaySink.prototype.error = Sink.prototype.error;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/delay.js\n ** module id = 70\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Sink = require('../sink/Pipe');\n\nexports.timestamp = timestamp;\n\nfunction timestamp(stream) {\n\treturn new Stream(new Timestamp(stream.source));\n}\n\nfunction Timestamp(source) {\n\tthis.source = source;\n}\n\nTimestamp.prototype.run = function(sink, scheduler) {\n\treturn this.source.run(new TimestampSink(sink), scheduler);\n};\n\nfunction TimestampSink(sink) {\n\tthis.sink = sink;\n}\n\nTimestampSink.prototype.end   = Sink.prototype.end;\nTimestampSink.prototype.error = Sink.prototype.error;\n\nTimestampSink.prototype.event = function(t, x) {\n\tthis.sink.event(t, { time: t, value: x });\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/timestamp.js\n ** module id = 71\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar Sink = require('../sink/Pipe');\nvar CompoundDisposable = require('../disposable/CompoundDisposable');\nvar PropagateTask = require('../scheduler/PropagateTask');\n\nexports.throttle = throttle;\nexports.debounce = debounce;\n\n/**\n * Limit the rate of events by suppressing events that occur too often\n * @param {Number} period time to suppress events\n * @param {Stream} stream\n * @returns {Stream}\n */\nfunction throttle(period, stream) {\n\treturn new Stream(new Throttle(period, stream.source));\n}\n\nfunction Throttle(period, source) {\n\tthis.dt = period;\n\tthis.source = source;\n}\n\nThrottle.prototype.run = function(sink, scheduler) {\n\treturn this.source.run(new ThrottleSink(this.dt, sink), scheduler);\n};\n\nfunction ThrottleSink(dt, sink) {\n\tthis.time = 0;\n\tthis.dt = dt;\n\tthis.sink = sink;\n}\n\nThrottleSink.prototype.event = function(t, x) {\n\tif(t >= this.time) {\n\t\tthis.time = t + this.dt;\n\t\tthis.sink.event(t, x);\n\t}\n};\n\nThrottleSink.prototype.end   = function(t, e) {\n\treturn Sink.prototype.end.call(this, t, e);\n};\n\nThrottleSink.prototype.error = Sink.prototype.error;\n\n/**\n * Wait for a burst of events to subside and emit only the last event in the burst\n * @param {Number} period events occuring more frequently than this\n *  will be suppressed\n * @param {Stream} stream stream to debounce\n * @returns {Stream} new debounced stream\n */\nfunction debounce(period, stream) {\n\treturn new Stream(new Debounce(period, stream.source));\n}\n\nfunction Debounce(dt, source) {\n\tthis.dt = dt;\n\tthis.source = source;\n}\n\nDebounce.prototype.run = function(sink, scheduler) {\n\treturn new DebounceSink(this.dt, this.source, sink, scheduler);\n};\n\nfunction DebounceSink(dt, source, sink, scheduler) {\n\tthis.dt = dt;\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n\tthis.value = void 0;\n\tthis.timer = null;\n\n\tvar sourceDisposable = source.run(this, scheduler);\n\tthis.disposable = new CompoundDisposable([this, sourceDisposable]);\n}\n\nDebounceSink.prototype.event = function(t, x) {\n\tthis._clearTimer();\n\tthis.value = x;\n\tthis.timer = this.scheduler.delay(this.dt, PropagateTask.event(x, this.sink));\n};\n\nDebounceSink.prototype.end = function(t, x) {\n\tif(this._clearTimer()) {\n\t\tthis.sink.event(t, this.value);\n\t\tthis.value = void 0;\n\t}\n\tthis.sink.end(t, x);\n};\n\nDebounceSink.prototype.error = function(t, x) {\n\tthis._clearTimer();\n\tthis.sink.error(t, x);\n};\n\nDebounceSink.prototype.dispose = function() {\n\tthis._clearTimer();\n};\n\nDebounceSink.prototype._clearTimer = function() {\n\tif(this.timer === null) {\n\t\treturn false;\n\t}\n\tthis.timer.cancel();\n\tthis.timer = null;\n\treturn true;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/limit.js\n ** module id = 72\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar resolve = require('../Promise').resolve;\nvar fatal = require('../fatalError');\n\nexports.fromPromise = fromPromise;\nexports.await = await;\n\nfunction fromPromise(p) {\n\treturn new Stream(new PromiseSource(p));\n}\n\nfunction PromiseSource(p) {\n\tthis.promise = p;\n}\n\nPromiseSource.prototype.run = function(sink, scheduler) {\n\treturn new PromiseProducer(this.promise, sink, scheduler);\n};\n\nfunction PromiseProducer(p, sink, scheduler) {\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n\tthis.active = true;\n\n\tvar self = this;\n\tresolve(p).then(function(x) {\n\t\tself._emit(self.scheduler.now(), x);\n\t}).catch(function(e) {\n\t\tself._error(self.scheduler.now(), e);\n\t});\n}\n\nPromiseProducer.prototype._emit = function(t, x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\n\tthis.sink.event(t, x);\n\tthis.sink.end(t, void 0);\n};\n\nPromiseProducer.prototype._error = function(t, e) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\n\tthis.sink.error(t, e);\n};\n\nPromiseProducer.prototype.dispose = function() {\n\tthis.active = false;\n};\n\nfunction await(stream) {\n\treturn new Stream(new Await(stream.source));\n}\n\nfunction Await(source) {\n\tthis.source = source;\n}\n\nAwait.prototype.run = function(sink, scheduler) {\n\treturn this.source.run(new AwaitSink(sink, scheduler), scheduler);\n};\n\nfunction AwaitSink(sink, scheduler) {\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n\tthis.queue = void 0;\n}\n\nAwaitSink.prototype.event = function(t, promise) {\n\tvar self = this;\n\tthis.queue = resolve(this.queue).then(function() {\n\t\treturn self._event(t, promise);\n\t}).catch(function(e) {\n\t\treturn self._error(t, e);\n\t});\n};\n\nAwaitSink.prototype.end = function(t, x) {\n\tvar self = this;\n\tthis.queue = resolve(this.queue).then(function() {\n\t\treturn self._end(t, x);\n\t}).catch(function(e) {\n\t\treturn self._error(t, e);\n\t});\n};\n\nAwaitSink.prototype.error = function(t, e) {\n\tvar self = this;\n\tthis.queue = resolve(this.queue).then(function() {\n\t\treturn self._error(t, e);\n\t}).catch(fatal);\n};\n\nAwaitSink.prototype._error = function(t, e) {\n\ttry {\n\t\t// Don't resolve error values, propagate directly\n\t\tthis.sink.error(Math.max(t, this.scheduler.now()), e);\n\t} catch(e) {\n\t\tfatal(e);\n\t\tthrow e;\n\t}\n};\n\nAwaitSink.prototype._event = function(t, promise) {\n\tvar self = this;\n\treturn promise.then(function(x) {\n\t\tself.sink.event(Math.max(t, self.scheduler.now()), x);\n\t});\n};\n\nAwaitSink.prototype._end = function(t, x) {\n\tvar self = this;\n\treturn resolve(x).then(function(x) {\n\t\tself.sink.end(Math.max(t, self.scheduler.now()), x);\n\t});\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/promises.js\n ** module id = 73\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Stream = require('../Stream');\nvar ValueSource = require('../source/ValueSource');\n\nexports.flatMapError = flatMapError;\nexports.throwError   = throwError;\n\n/**\n * If stream encounters an error, recover and continue with items from stream\n * returned by f.\n * @param {function(error:*):Stream} f function which returns a new stream\n * @param {Stream} stream\n * @returns {Stream} new stream which will recover from an error by calling f\n */\nfunction flatMapError(f, stream) {\n\treturn new Stream(new FlatMapError(f, stream.source));\n}\n\n/**\n * Create a stream containing only an error\n * @param {*} e error value, preferably an Error or Error subtype\n * @returns {Stream} new stream containing only an error\n */\nfunction throwError(e) {\n\treturn new Stream(new ValueSource(error, e));\n}\n\nfunction error(t, e, sink) {\n\tsink.error(t, e);\n}\n\nfunction FlatMapError(f, source) {\n\tthis.f = f;\n\tthis.source = source;\n}\n\nFlatMapError.prototype.run = function(sink, scheduler) {\n\treturn new FlatMapErrorSink(this.f, this.source, sink, scheduler);\n};\n\nfunction FlatMapErrorSink(f, source, sink, scheduler) {\n\tthis.f = f;\n\tthis.sink = sink;\n\tthis.scheduler = scheduler;\n\tthis.active = true;\n\tthis.disposable = source.run(this, scheduler);\n}\n\nFlatMapErrorSink.prototype.error = function(t, e) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\n\t// TODO: forward dispose errors\n\tthis.disposable.dispose();\n\t//resolve(this.disposable.dispose()).catch(function(e) { sink.error(t, e); });\n\n\tvar f = this.f;\n\tvar stream = f(e);\n\tthis.disposable = stream.source.run(this.sink, this.scheduler);\n};\n\nFlatMapErrorSink.prototype.event = function(t, x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\tthis.sink.event(t, x);\n};\n\nFlatMapErrorSink.prototype.end = function(t, x) {\n\tif(!this.active) {\n\t\treturn;\n\t}\n\tthis.sink.end(t, x);\n};\n\nFlatMapErrorSink.prototype.dispose = function() {\n\tthis.active = false;\n\treturn this.disposable.dispose();\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/errors.js\n ** module id = 74\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2015 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n/** @contributor Maciej Ligenza */\n\nvar Stream = require('../Stream');\nvar MulticastSource = require('../source/MulticastSource');\n\nexports.multicast = multicast;\n\n/**\n * Transform the stream into a multicast stream, allowing it to be shared\n * more efficiently by many observers, without causing multiple invocation\n * of internal machinery.  Multicast is idempotent:\n * stream.multicast() === stream.multicast().multicast()\n * @param {Stream} stream to ensure is multicast.\n * @returns {Stream} new stream which will multicast events to all observers.\n */\nfunction multicast(stream) {\n\tvar source = stream.source;\n\treturn source instanceof MulticastSource ? stream : new Stream(new MulticastSource(source));\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/most/lib/combinator/multicast.js\n ** module id = 75\n ** module chunks = 0\n **/","import most from 'most'\n\nvar setImmediate;\nif (typeof setImmediate === \"undefined\" || setImmediate === null) {\n  setImmediate = function(f) {\n    return setTimeout(f, 0);\n  };\n}\n\nexport function bus(initial) {\n  var b$, _add, _end, _error;\n  _add = _end = _error = null;\n  b$ = most.create(function(add, end, error) {\n    _add = add;\n    _end = end;\n    return _error = error;\n  });\n  b$.push = function(v) {\n    return setImmediate(function() {\n      return typeof _add === \"function\" ? _add(v) : void 0;\n    });\n  };\n  b$.end = function() {\n    return setImmediate(function() {\n      return typeof _end === \"function\" ? _end() : void 0;\n    });\n  };\n  b$.error = function(e) {\n    return setImmediate(function() {\n      return typeof _error === \"function\" ? _error(e) : void 0;\n    });\n  };\n  b$.plug = function(v$) {\n    var w$;\n    w$ = bus();\n    v$.forEach(w$.push);\n    w$.forEach(b$.push);\n    return w$.end;\n  };\n  if (initial != null) {\n    b$.push(initial);\n  }\n  b$.observe(function(){}) //ensure at least one observer\n  return b$;\n};\nexport default bus\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lupin/src/bus.js\n **/","import stream from 'most'\n\n//Split stream of arrays into an array of streams, or a map of streams\nexport default function split(stream, fields=2) {\n  let s = stream.multicast()\n  let streams = []\n  if (typeof fields == 'number') {\n    for (var i=0; i<fields; i++) {\n      let j = i\n      streams.push(s.filter(l => l.length > j).map(o => o[j]))\n    }\n  } else {\n    streams = {}\n    fields.forEach(f => {\n      streams[f] = s.map(o => o[f])\n    })\n  }\n  return streams\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lupin/src/split.js\n **/","/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Immutable = factory()\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32−1.\n    // However note that we're currently calling ToNumber() instead of ToUint32()\n    // which should be improved in the future, as floating point numbers should\n    // not be accepted as an array index.\n    if (typeof index !== 'number') {\n      var numIndex = +index;\n      if ('' + numIndex !== index) {\n        return NaN;\n      }\n      index = numIndex;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function src_Iterator__Iterator(next) {\n      this.next = next;\n    }\n\n    src_Iterator__Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  src_Iterator__Iterator.KEYS = ITERATE_KEYS;\n  src_Iterator__Iterator.VALUES = ITERATE_VALUES;\n  src_Iterator__Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  src_Iterator__Iterator.prototype.inspect =\n  src_Iterator__Iterator.prototype.toSource = function () { return this.toString(); }\n  src_Iterator__Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  // #pragma Root Sequences\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new src_Iterator__Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new src_Iterator__Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new src_Iterator__Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new src_Iterator__Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new src_Iterator__Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new src_Iterator__Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' &&\n        typeof valueB.equals === 'function' &&\n        valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  var src_Math__imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    return hashJSObj(o);\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new src_Iterator__Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.includes = function(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new src_Iterator__Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new src_Iterator__Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(\n            indexedIterable ? entry.get(1) : entry[1],\n            indexedIterable ? entry.get(0) : entry[0],\n            this$0\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new src_Iterator__Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(\n              type,\n              indexedIterable ? entry.get(0) : entry[0],\n              indexedIterable ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.includes(key)};\n    flipSequence.includes = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new src_Iterator__Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new src_Iterator__Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new src_Iterator__Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = src_Map__Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : src_Map__Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new src_Iterator__Iterator(function()  {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new src_Iterator__Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new src_Iterator__Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new src_Iterator__Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new src_Iterator__Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new src_Iterator__Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(src_Map__Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function src_Map__Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) && !isOrdered(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    src_Map__Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    src_Map__Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    src_Map__Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    src_Map__Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    src_Map__Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    src_Map__Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    src_Map__Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    src_Map__Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    src_Map__Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    src_Map__Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    src_Map__Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    src_Map__Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.merge === 'function' ?\n          m.merge.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    src_Map__Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger(undefined), arguments);\n    };\n\n    src_Map__Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMerger(merger), iters);\n    };\n\n    src_Map__Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.mergeDeep === 'function' ?\n          m.mergeDeep.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    src_Map__Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    src_Map__Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    src_Map__Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    src_Map__Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    src_Map__Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    src_Map__Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    src_Map__Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    src_Map__Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    src_Map__Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  src_Map__Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = src_Map__Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, src_Iterator__Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(merger) {\n    return function(existing, value, key) \n      {return existing && existing.mergeDeepWith && isIterable(value) ?\n        existing.mergeDeepWith(merger, value) :\n        merger ? merger(existing, value, key) : value};\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value, key)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger(undefined), arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMerger(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new src_Iterator__Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, src_Map__Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new src_Iterator__Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  createClass(src_Set__Set, SetCollection);\n\n    // @pragma Construction\n\n    function src_Set__Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) && !isOrdered(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    src_Set__Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    src_Set__Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    src_Set__Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    src_Set__Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    src_Set__Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    src_Set__Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    src_Set__Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    src_Set__Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    src_Set__Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    src_Set__Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    src_Set__Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    src_Set__Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    src_Set__Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    src_Set__Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    src_Set__Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    src_Set__Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    src_Set__Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    src_Set__Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  src_Set__Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = src_Set__Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, src_Set__Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var hasInitialized;\n\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = src_Map__Map(values);\n      };\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step > 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.includes = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new src_Iterator__Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new src_Iterator__Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = src_Iterator__Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return src_Map__Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return src_Set__Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    findEntry: function(predicate, context) {\n      var found;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findLastEntry: function(predicate, context) {\n      return this.toSeq().reverse().findEntry(predicate, context);\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.includes(value)});\n    },\n\n    isSuperset: function(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  // Temporary warning about using length\n  (function () {\n    try {\n      Object.defineProperty(IterablePrototype, 'length', {\n        get: function () {\n          if (!Iterable.noLengthWarning) {\n            var stack;\n            try {\n              throw new Error();\n            } catch (error) {\n              stack = error.stack;\n            }\n            if (stack.indexOf('_wrapObject') === -1) {\n              console && console.warn && console.warn(\n                'iterable.length has been deprecated, '+\n                'use iterable.size or iterable.count(). '+\n                'This warning will become a silent error in a future version. ' +\n                stack\n              );\n              return this.size;\n            }\n          }\n        }\n      });\n    } catch (e) {}\n  })();\n\n\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toSeq().reverse().findKey(predicate, context);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.findLastKey(function(value ) {return is(value, searchValue)});\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.toKeyedSeq().keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      return this.toSeq().reverse().indexOf(searchValue);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var key = this.toKeyedSeq().findLastKey(predicate, context);\n      return key === undefined ? -1 : key;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : value;\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = src_Math__imul(h, 0xCC9E2D51);\n    h = src_Math__imul(h << 15 | h >>> -15, 0x1B873593);\n    h = src_Math__imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = src_Math__imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = src_Math__imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: src_Map__Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: src_Set__Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/immutable/dist/immutable.js\n ** module id = 78\n ** module chunks = 0\n **/","//This todo application is a bit more complex than necessary so you \n//can scale the example into a more substantial application\n//This example is defined in modules - but there is only one module\n\nimport Immutable from 'immutable';\nimport Riot from 'riot';\n\n\nimport TODO_STATE from './model';\nimport processor from './processor.js';\nimport './tags.js';\n\nexport function init( core) {\n  // set ToDoProcessor to recieve all events\n  // should lupin support subscriptions on a event basis ?\n  core.register( processor);\n\n  // enable riot for the todo module by mounting the top level tag\n  Riot.mount('todo-app', {core});\n}\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/todo/module.js\n **/","/* \n\tDefine the objects which will be stored in the application state. These \n\tobjects and collections should all be immutable.\n*/\n\n// Use immutable from facebook to manage state objects\nimport Immutable from 'immutable';\n\n// define the label for all application state from this module\nexport const TODO_STATE = \"todos\";  \n\n// create the objects for the module\nexport function todo(title, description) {\n\n  // create a \"unique tag\" for each task. Lots of other ways to do this\n  function guid() { \n\tfunction S4() {\n\t\t// create a substring filled with random characters\n    \treturn (((1+Math.random())*0x10000)|0).toString(16).substring(1);\n\t}\n\n\t// then to call it, plus stitch in '4' in the third group\n\treturn (S4() + S4() + \"-\" + S4() + \"-4\" + \n\t\tS4().substr(0,3) + \"-\" + S4() + \"-\" + S4() + S4() + S4()).toLowerCase();\n  }\n\n  return Immutable.fromJS( {\n    id: guid(),\n\ttitle,\n\tdescription,\n\tdone: false\n  })\n} \n\n\n\n/** WEBPACK FOOTER **\n ** ./src/todo/model.js\n **/","// TodoProcessor definition.\n// The processor implements the application logic by responding to \n// relevant events emitted via the Lupin.\n\n'use strict';\nimport Immutable from 'immutable';\nimport * as events from './signals';  // module specific events\nimport { todo, TODO_STATE } from './model'; // module specific data model\n\n\nexport default function processor( state, signal) {\n  // this is a single event processor for the entire module. Multiple processors\n  // could be used to segregate functions\n  switch (signal.type) {\n    case events.ADD_TODO:\n      state = state.setIn(\n        // find the todo list in the state and set the key\n        [ TODO_STATE, signal.todo.toJS().id ], \n        // insert the new todo instance from the signal\n        signal.todo \n      );\n      break;\n\n    case events.TOGGLE_TODO:\n      // find the right todo in state and flip its done status\n      state = state.updateIn( [ TODO_STATE, signal.key, \"done\"], done => !done);\n      break;\n\n    case events.CLEAR_TODOS:\n      // remove the todos that are flagged as done\n      state = state.update( TODO_STATE, \n        todos => todos.filterNot( todo => todo.get('done')));\n\n      break;\n\n    case events.INIT_TODOS:\n      // load stored todos or other startup step \n\n      // initialize the core store for this module's model\n      // this should be part of \"register\" up in lupin\n      state = state.set( TODO_STATE, Immutable.Map());\n      // Lupin should probably manage the state stack     \n    break;\n  }\n  return [state];\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/todo/processor.js\n **/","/*\n\tThis file defines the module specific events \n   \n\tThe events in this application are scoped by module \"Todo:\" to avoid\n\tname conflicts between modules. The namespace is shared between all modules\n\tin your application. The variable names you use to hold them are not exposed outside\n\tthe module.\n\n*/\n\nexport const ADD_TODO = 'Todo:Add'; // includes a full todo instance\nexport const TOGGLE_TODO = 'Todo:Toggle' // includes the index of the todo instance\nexport const CLEAR_TODOS = 'Todo:Clear' // no parameters\nexport const INIT_TODOS = 'Todo:Init' // no parameters\n\n// define the functions for creating each event type for the module\nexport function addTodo( todo) { return { type: ADD_TODO, todo }; }\nexport function toggleTodo( key) { return { type: TOGGLE_TODO, key }; }\nexport function clearTodos( ) { return { type: CLEAR_TODOS }; }\nexport function initTodos( ) { return { type: INIT_TODOS }; }\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/todo/signals.js\n **/","import riot from 'riot';\nimport Lupin from 'lupin';\nimport * as events from './signals';\nimport Immutable from 'immutable';\nimport { todo, TODO_STATE } from './model';\n\nriot.tag('todo-app',\n\n  `<h3>Todos</h3>\n   <todo-form core=\"{opts.core}\"></todo-form>\n   <todo-list core=\"{opts.core}\"></todo-list>\n   <p>\n     Want a second fully synchronized list? Just declare another list component:\n     no code required, no events to wire up!\n   </p>\n   <todo-list core=\"{opts.core}\"></todo-list>`,\n\n  function(opts) {\n    // set up the todo list once the form has been mounted\n    this.on('mount', () => this.opts.core.signals.push( events.initTodos()));\n  }\n\n);\n\n\nriot.tag('todo-form',\n\n  `<input id=\"todoTitle\" type=\"text\" placeholder=\"New Todo Title\" autofocus=\"true\">\n   <input id=\"todoDescription\" type=\"text\" placeholder=\"Description\">\n   <button onclick=\"{add}\">Add ToDo</button>\n   <button onclick=\"{clear}\">Clear Completed</button>`,\n\n  function(opts) {\n    let core = this.opts.core;\n\n    this.add = (e) => {\n      // handle the user click on the add button\n      if (this.todoTitle.value) {\n        core.signals.push( // raise an event to update the model state\n          events.addTodo( // create the event\n            // this event needs a new todo instance\n            todo( this.todoTitle.value, this.todoDescription.value)\n          )\n        );\n        // now clear the user's input\n        this.todoTitle.value = '';\n        this.todoDescription.value = '';\n      }\n    };\n\n    this.clear = (e) => {\n      // handle the user click on the clear button\n      // create the clear event and raise it\n      core.signals.push( events.clearTodos() );\n    };\n  }\n\n);\n\n\nriot.tag('todo-list',\n\n  `<ul>\n     <li each=\"{todo in todoMap.toArray()}\">\n       <todo-item core=\"{parent.opts.core}\" todo=\"{todo.toObject()}\">\n     </li>\n   </ul>`,\n\n  function(opts) {\n    // initialise the shadow DOM viewmodel to empty.\n    if( !(\"todoMap\" in this) ) this.todoMap = null;\n\n    // subscribe to changes in the relevant state\n    this.opts.core.state.observe( (state) => { \n      // on each change, update the viewmodel content\n      // get the todo module state if it exists\n      var tmp = state.get( TODO_STATE);\n\n      if( tmp !== undefined && // the todo state has been established\n          this.todoMap !== tmp) { // the state is not the same as last time\n        // attach the immutalbe map to the list\n        this.todoMap = tmp;\n        // tell riot to update the view\n        this.update();\n      }\n    })\n  }\n\n);\n\n\nriot.tag('todo-item',\n\n  `<span class=\"{done: opts.todo.done}\" onclick=\"{toggle}\">\n     {opts.todo.title} - {opts.todo.description}\n   </span>`,\n\n  function(opts) {\n    // handle clicks on tasks \n    this.toggle = () => {\n      // raise the toggle event\n      this.opts.core.signals.push( \n        // create the toggle event with the id of the clicked task\n        events.toggleTodo( this.todo.toObject().id) \n      );\n    }\n  }\n\n);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/todo/tags.js\n **/"],"sourceRoot":""}